package lambda

import (
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/lambda"
	"github.com/aws/aws-sdk-go-v2/service/lambda/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TDD Tests for Basic Invocation Functions using existing MockLambdaClient

func TestMarshalPayloadE_BasicTDD(t *testing.T) {
	t.Run("ValidStruct", func(t *testing.T) {
		data := map[string]interface{}{
			"key":    "value",
			"number": 123,
			"bool":   true,
		}
		
		result, err := MarshalPayloadE(data)
		require.NoError(t, err)
		assert.Contains(t, result, `"key":"value"`)
		assert.Contains(t, result, `"number":123`)
		assert.Contains(t, result, `"bool":true`)
	})
	
	t.Run("NilPayload", func(t *testing.T) {
		result, err := MarshalPayloadE(nil)
		require.NoError(t, err)
		assert.Equal(t, "", result)
	})
	
	t.Run("InvalidStruct", func(t *testing.T) {
		data := struct {
			Ch chan int `json:"channel"`
		}{
			Ch: make(chan int),
		}
		
		_, err := MarshalPayloadE(data)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to marshal payload")
	})
}

func TestMarshalPayload_BasicTDD(t *testing.T) {
	t.Run("ValidStruct_ShouldNotPanic", func(t *testing.T) {
		data := struct {
			Name  string `json:"name"`
			Value int    `json:"value"`
		}{
			Name:  "test",
			Value: 42,
		}
		
		assert.NotPanics(t, func() {
			result := MarshalPayload(data)
			assert.Contains(t, result, `"name":"test"`)
			assert.Contains(t, result, `"value":42`)
		})
	})
	
	t.Run("NilPayload", func(t *testing.T) {
		result := MarshalPayload(nil)
		assert.Equal(t, "", result)
	})
	
	t.Run("InvalidPayload_ShouldPanic", func(t *testing.T) {
		data := struct {
			Ch chan int
		}{
			Ch: make(chan int),
		}
		
		assert.Panics(t, func() {
			MarshalPayload(data)
		})
	})
}

func TestParseInvokeOutputE_BasicTDD(t *testing.T) {
	t.Run("ValidJSONPayload", func(t *testing.T) {
		result := &InvokeResult{
			StatusCode: 200,
			Payload:    `{"status": "ok", "count": 5}`,
		}
		
		var target map[string]interface{}
		err := ParseInvokeOutputE(result, &target)
		require.NoError(t, err)
		
		assert.Equal(t, "ok", target["status"])
		assert.Equal(t, float64(5), target["count"]) // JSON numbers are float64
	})
	
	t.Run("NilResult", func(t *testing.T) {
		var target map[string]interface{}
		err := ParseInvokeOutputE(nil, &target)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invoke result is nil")
	})
	
	t.Run("EmptyPayload", func(t *testing.T) {
		result := &InvokeResult{
			StatusCode: 200,
			Payload:    "",
		}
		
		var target map[string]interface{}
		err := ParseInvokeOutputE(result, &target)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "payload is empty")
	})
	
	t.Run("InvalidJSONPayload", func(t *testing.T) {
		result := &InvokeResult{
			StatusCode: 200,
			Payload:    `{"broken": json}`,
		}
		
		var target map[string]interface{}
		err := ParseInvokeOutputE(result, &target)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to unmarshal payload")
	})
}

func TestParseInvokeOutput_BasicTDD(t *testing.T) {
	t.Run("ValidJSONPayload_ShouldNotPanic", func(t *testing.T) {
		result := &InvokeResult{
			StatusCode: 200,
			Payload:    `{"message": "success", "data": {"key": "value"}}`,
		}
		
		var target map[string]interface{}
		assert.NotPanics(t, func() {
			ParseInvokeOutput(result, &target)
		})
		
		assert.Equal(t, "success", target["message"])
		assert.Contains(t, target, "data")
	})
	
	t.Run("InvalidJSONPayload_ShouldPanic", func(t *testing.T) {
		result := &InvokeResult{
			StatusCode: 200,
			Payload:    `{"invalid": json}`,
		}
		
		var target map[string]interface{}
		assert.Panics(t, func() {
			ParseInvokeOutput(result, &target)
		})
	})
}

// Test Input Validation Functions

func TestValidateFunctionName_TDD(t *testing.T) {
	validationScenarios := []struct {
		name         string
		functionName string
		expectError  bool
		errorMessage string
	}{
		{
			name:         "ValidFunctionName",
			functionName: "my-test-function",
			expectError:  false,
		},
		{
			name:         "ValidFunctionNameWithNumbers",
			functionName: "function123",
			expectError:  false,
		},
		{
			name:         "ValidFunctionNameWithUnderscores",
			functionName: "my_test_function",
			expectError:  false,
		},
		{
			name:         "EmptyFunctionName",
			functionName: "",
			expectError:  true,
			errorMessage: "invalid function name",
		},
		{
			name:         "TooLongFunctionName",
			functionName: "this-function-name-is-way-too-long-to-be-valid-in-aws-lambda-and-should-fail-validation",
			expectError:  true,
			errorMessage: "name too long",
		},
		{
			name:         "InvalidCharacters",
			functionName: "function-name-with-!@#",
			expectError:  true,
			errorMessage: "invalid character",
		},
		{
			name:         "InvalidCharactersSpaces",
			functionName: "function name with spaces",
			expectError:  true,
			errorMessage: "invalid character",
		},
	}
	
	for _, scenario := range validationScenarios {
		t.Run(scenario.name, func(t *testing.T) {
			err := validateFunctionName(scenario.functionName)
			
			if scenario.expectError {
				assert.Error(t, err)
				if scenario.errorMessage != "" {
					assert.Contains(t, err.Error(), scenario.errorMessage)
				}
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidatePayload_TDD(t *testing.T) {
	payloadScenarios := []struct {
		name         string
		payload      string
		expectError  bool
		errorMessage string
	}{
		{
			name:        "ValidJSONPayload",
			payload:     `{"key": "value", "number": 42}`,
			expectError: false,
		},
		{
			name:        "EmptyPayload",
			payload:     "",
			expectError: false, // Empty payload is valid
		},
		{
			name:        "ValidJSONArray",
			payload:     `[{"item": 1}, {"item": 2}]`,
			expectError: false,
		},
		{
			name:        "ValidJSONString",
			payload:     `"simple string"`,
			expectError: false,
		},
		{
			name:        "ValidJSONNumber",
			payload:     `42`,
			expectError: false,
		},
		{
			name:        "ValidJSONBoolean",
			payload:     `true`,
			expectError: false,
		},
		{
			name:         "InvalidJSON",
			payload:      `{"invalid": json}`,
			expectError:  true,
			errorMessage: "invalid payload format",
		},
		{
			name:         "InvalidJSONTrailingComma",
			payload:      `{"key": "value",}`,
			expectError:  true,
			errorMessage: "invalid payload format",
		},
		{
			name:         "InvalidJSONMissingQuotes",
			payload:      `{key: "value"}`,
			expectError:  true,
			errorMessage: "invalid payload format",
		},
	}
	
	for _, scenario := range payloadScenarios {
		t.Run(scenario.name, func(t *testing.T) {
			err := validatePayload(scenario.payload)
			
			if scenario.expectError {
				assert.Error(t, err)
				if scenario.errorMessage != "" {
					assert.Contains(t, err.Error(), scenario.errorMessage)
				}
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

// Test Option Merging

func TestMergeInvokeOptions_TDD(t *testing.T) {
	t.Run("NilOptions_ShouldReturnDefaults", func(t *testing.T) {
		result := mergeInvokeOptions(nil)
		
		assert.Equal(t, InvocationTypeRequestResponse, result.InvocationType)
		assert.Equal(t, LogTypeNone, result.LogType)
		assert.Equal(t, DefaultTimeout, result.Timeout)
		assert.Equal(t, DefaultRetryAttempts, result.MaxRetries)
		assert.Equal(t, DefaultRetryDelay, result.RetryDelay)
		assert.NotNil(t, result.PayloadValidator)
	})
	
	t.Run("PartialOptions_ShouldMergeWithDefaults", func(t *testing.T) {
		userOpts := &InvokeOptions{
			InvocationType: types.InvocationTypeEvent,
			Timeout:        60 * time.Second,
		}
		
		result := mergeInvokeOptions(userOpts)
		
		// User values should be preserved
		assert.Equal(t, types.InvocationTypeEvent, result.InvocationType)
		assert.Equal(t, 60*time.Second, result.Timeout)
		
		// Defaults should be applied for unspecified values
		assert.Equal(t, LogTypeNone, result.LogType)
		assert.Equal(t, DefaultRetryAttempts, result.MaxRetries)
		assert.Equal(t, DefaultRetryDelay, result.RetryDelay)
		assert.NotNil(t, result.PayloadValidator)
	})
	
	t.Run("CompleteOptions_ShouldPreserveAll", func(t *testing.T) {
		customValidator := func(payload string) error { return nil }
		userOpts := &InvokeOptions{
			InvocationType:   types.InvocationTypeDryRun,
			LogType:          LogTypeTail,
			ClientContext:    "test-context",
			Qualifier:        "PROD",
			Timeout:          45 * time.Second,
			MaxRetries:       5,
			RetryDelay:       2 * time.Second,
			PayloadValidator: customValidator,
		}
		
		result := mergeInvokeOptions(userOpts)
		
		assert.Equal(t, types.InvocationTypeDryRun, result.InvocationType)
		assert.Equal(t, LogTypeTail, result.LogType)
		assert.Equal(t, "test-context", result.ClientContext)
		assert.Equal(t, "PROD", result.Qualifier)
		assert.Equal(t, 45*time.Second, result.Timeout)
		assert.Equal(t, 5, result.MaxRetries)
		assert.Equal(t, 2*time.Second, result.RetryDelay)
		// Note: function equality can't be tested directly, so we just ensure it's not nil
		assert.NotNil(t, result.PayloadValidator)
	})
}

// Test Backoff Calculation

func TestCalculateBackoffDelay_TDD(t *testing.T) {
	config := RetryConfig{
		MaxAttempts: 5,
		BaseDelay:   1 * time.Second,
		MaxDelay:    30 * time.Second,
		Multiplier:  2.0,
	}
	
	t.Run("ZeroAttempt_ShouldReturnBaseDelay", func(t *testing.T) {
		delay := calculateBackoffDelay(0, config)
		assert.Equal(t, 1*time.Second, delay)
	})
	
	t.Run("NegativeAttempt_ShouldReturnBaseDelay", func(t *testing.T) {
		delay := calculateBackoffDelay(-1, config)
		assert.Equal(t, 1*time.Second, delay)
	})
	
	t.Run("ExponentialGrowth", func(t *testing.T) {
		// Attempt 1: 1s * 2^1 = 2s
		delay1 := calculateBackoffDelay(1, config)
		assert.Equal(t, 2*time.Second, delay1)
		
		// Attempt 2: 1s * 2^2 = 4s
		delay2 := calculateBackoffDelay(2, config)
		assert.Equal(t, 4*time.Second, delay2)
		
		// Attempt 3: 1s * 2^3 = 8s
		delay3 := calculateBackoffDelay(3, config)
		assert.Equal(t, 8*time.Second, delay3)
	})
	
	t.Run("MaxDelayCapReached", func(t *testing.T) {
		// High attempts should cap at MaxDelay
		delay := calculateBackoffDelay(10, config) // Would be 1024s without cap
		assert.Equal(t, 30*time.Second, delay)
	})
	
	t.Run("OverflowProtection", func(t *testing.T) {
		extremeConfig := RetryConfig{
			BaseDelay:  1 * time.Second,
			MaxDelay:   10 * time.Second,
			Multiplier: 1000.0, // Extreme multiplier to test overflow protection
		}
		
		delay := calculateBackoffDelay(5, extremeConfig)
		assert.Equal(t, 10*time.Second, delay) // Should be capped at MaxDelay
	})
}

// Test Log Result Sanitization

func TestSanitizeLogResult_TDD(t *testing.T) {
	t.Run("RemoveRequestIds", func(t *testing.T) {
		input := `START RequestId: abc123-def456-ghi789 Version: $LATEST
INFO	Function executed successfully
RequestId: abc123-def456-ghi789	Function executed
END RequestId: abc123-def456-ghi789`
		
		result := sanitizeLogResult(input)
		
		// Should remove lines containing RequestId but keep the INFO line
		assert.Contains(t, result, "Function executed successfully")
		assert.NotContains(t, result, "RequestId:")
		assert.NotContains(t, result, "START")
		assert.NotContains(t, result, "END")
	})
	
	t.Run("RemoveDurationInfo", func(t *testing.T) {
		input := `INFO	Processing data
Duration: 100.50 ms	Billed Duration: 101 ms	Memory Size: 128 MB	Max Memory Used: 64 MB
INFO	Processing complete`
		
		result := sanitizeLogResult(input)
		
		// Should remove duration line but keep INFO lines
		assert.Contains(t, result, "Processing data")
		assert.Contains(t, result, "Processing complete")
		assert.NotContains(t, result, "Duration:")
		assert.NotContains(t, result, "Billed Duration:")
	})
	
	t.Run("EmptyInput", func(t *testing.T) {
		result := sanitizeLogResult("")
		assert.Equal(t, "", result)
	})
	
	t.Run("OnlyUserLogs", func(t *testing.T) {
		input := `INFO	User log message 1
ERROR	User error message
DEBUG	Debug information`
		
		result := sanitizeLogResult(input)
		
		// Should preserve all user logs
		assert.Contains(t, result, "User log message 1")
		assert.Contains(t, result, "User error message")
		assert.Contains(t, result, "Debug information")
	})
	
	t.Run("MixedContent", func(t *testing.T) {
		input := `START RequestId: xyz789
INFO	Application starting
Duration: 50.25 ms
INFO	Processing request
INFO	Request completed
END RequestId: xyz789
Billed Duration: 51 ms`
		
		result := sanitizeLogResult(input)
		lines := strings.Split(result, "\n")
		
		// Should only have the user INFO lines
		var nonEmptyLines []string
		for _, line := range lines {
			if strings.TrimSpace(line) != "" {
				nonEmptyLines = append(nonEmptyLines, line)
			}
		}
		
		assert.Len(t, nonEmptyLines, 3)
		assert.Contains(t, result, "Application starting")
		assert.Contains(t, result, "Processing request") 
		assert.Contains(t, result, "Request completed")
		assert.NotContains(t, result, "RequestId:")
		assert.NotContains(t, result, "Duration:")
	})
}

// Test utility functions

func TestInvokeOptionsDefaults_TDD(t *testing.T) {
	t.Run("DefaultInvokeOptions", func(t *testing.T) {
		defaults := defaultInvokeOptions()
		
		assert.Equal(t, InvocationTypeRequestResponse, defaults.InvocationType)
		assert.Equal(t, LogTypeNone, defaults.LogType)
		assert.Equal(t, DefaultTimeout, defaults.Timeout)
		assert.Equal(t, DefaultRetryAttempts, defaults.MaxRetries)
		assert.Equal(t, DefaultRetryDelay, defaults.RetryDelay)
		assert.NotNil(t, defaults.PayloadValidator)
		
		// Test default payload validator
		err := defaults.PayloadValidator(`{"test": "payload"}`)
		assert.NoError(t, err, "Default validator should accept valid JSON")
		
		// Test default payload validator with oversized payload
		oversizedPayload := `{"data": "` + strings.Repeat("x", MaxPayloadSize) + `"}`
		err = defaults.PayloadValidator(oversizedPayload)
		assert.Error(t, err, "Default validator should reject oversized payload")
		assert.Contains(t, err.Error(), "payload size exceeds maximum")
	})
	
	t.Run("DefaultRetryConfig", func(t *testing.T) {
		config := defaultRetryConfig()
		
		assert.Equal(t, DefaultRetryAttempts, config.MaxAttempts)
		assert.Equal(t, DefaultRetryDelay, config.BaseDelay)
		assert.Equal(t, 30*time.Second, config.MaxDelay)
		assert.Equal(t, 2.0, config.Multiplier)
	})
}

// Test Constants

func TestLambdaConstants_TDD(t *testing.T) {
	t.Run("Constants_ShouldHaveCorrectValues", func(t *testing.T) {
		assert.Equal(t, 30*time.Second, DefaultTimeout)
		assert.Equal(t, int32(128), DefaultMemorySize)
		assert.Equal(t, 6*1024*1024, MaxPayloadSize) // 6MB
		assert.Equal(t, 3, DefaultRetryAttempts)
		assert.Equal(t, 1*time.Second, DefaultRetryDelay)
		
		// Test invocation types match AWS SDK types
		assert.Equal(t, types.InvocationTypeRequestResponse, InvocationTypeRequestResponse)
		assert.Equal(t, types.InvocationTypeEvent, InvocationTypeEvent)
		assert.Equal(t, types.InvocationTypeDryRun, InvocationTypeDryRun)
		
		// Test log types match AWS SDK types
		assert.Equal(t, types.LogTypeNone, LogTypeNone)
		assert.Equal(t, types.LogTypeTail, LogTypeTail)
	})
}

// Simple integration test using mocked client without testify/mock dependency

func TestInvokeE_SimpleMockIntegration_TDD(t *testing.T) {
	t.Run("SuccessfulInvocation", func(t *testing.T) {
		// Create a simple test context without real AWS config
		ctx := &TestContext{T: t}
		
		// Create mock client
		mockClient := &MockLambdaClient{
			InvokeResponse: &lambda.InvokeOutput{
				StatusCode: 200,
				Payload:    []byte(`{"result": "success"}`),
			},
			InvokeError: nil,
		}
		
		// Store original factory and replace with mock
		originalFactory := globalClientFactory
		mockFactory := &MockClientFactory{}
		mockFactory.SetLambdaClient(mockClient)
		globalClientFactory = mockFactory
		
		// Cleanup
		defer func() {
			globalClientFactory = originalFactory
		}()
		
		// Test the invocation
		result, err := InvokeE(ctx, "test-function", `{"key": "value"}`)
		
		require.NoError(t, err)
		assert.Equal(t, int32(200), result.StatusCode)
		assert.Equal(t, `{"result": "success"}`, result.Payload)
		assert.Greater(t, result.ExecutionTime, time.Duration(0))
		
		// Verify mock was called
		assert.Contains(t, mockClient.InvokeCalls, "test-function")
	})
}