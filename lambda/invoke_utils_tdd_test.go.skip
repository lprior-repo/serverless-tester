package lambda

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TDD Tests for Lambda Utility Functions

func TestMarshalPayloadE_TDD(t *testing.T) {
	t.Run("ValidStruct", func(t *testing.T) {
		data := map[string]interface{}{
			"key":    "value",
			"number": 123,
			"bool":   true,
		}
		
		result, err := MarshalPayloadE(data)
		require.NoError(t, err)
		assert.Contains(t, result, `"key":"value"`)
		assert.Contains(t, result, `"number":123`)
		assert.Contains(t, result, `"bool":true`)
	})
	
	t.Run("NilPayload", func(t *testing.T) {
		result, err := MarshalPayloadE(nil)
		require.NoError(t, err)
		assert.Equal(t, "", result)
	})
	
	t.Run("InvalidStruct", func(t *testing.T) {
		data := struct {
			Ch chan int `json:"channel"`
		}{
			Ch: make(chan int),
		}
		
		_, err := MarshalPayloadE(data)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to marshal payload")
	})
}

func TestMarshalPayload_TDD(t *testing.T) {
	t.Run("ValidStruct_ShouldNotPanic", func(t *testing.T) {
		data := struct {
			Name  string `json:"name"`
			Value int    `json:"value"`
		}{
			Name:  "test",
			Value: 42,
		}
		
		assert.NotPanics(t, func() {
			result := MarshalPayload(data)
			assert.Contains(t, result, `"name":"test"`)
			assert.Contains(t, result, `"value":42`)
		})
	})
	
	t.Run("NilPayload", func(t *testing.T) {
		result := MarshalPayload(nil)
		assert.Equal(t, "", result)
	})
	
	t.Run("InvalidPayload_ShouldPanic", func(t *testing.T) {
		data := struct {
			Ch chan int
		}{
			Ch: make(chan int),
		}
		
		assert.Panics(t, func() {
			MarshalPayload(data)
		})
	})
}

func TestParseInvokeOutputE_TDD(t *testing.T) {
	t.Run("ValidJSONPayload", func(t *testing.T) {
		result := &InvokeResult{
			StatusCode: 200,
			Payload:    `{"status": "ok", "count": 5}`,
		}
		
		var target map[string]interface{}
		err := ParseInvokeOutputE(result, &target)
		require.NoError(t, err)
		
		assert.Equal(t, "ok", target["status"])
		assert.Equal(t, float64(5), target["count"]) // JSON numbers are float64
	})
	
	t.Run("NilResult", func(t *testing.T) {
		var target map[string]interface{}
		err := ParseInvokeOutputE(nil, &target)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invoke result is nil")
	})
	
	t.Run("EmptyPayload", func(t *testing.T) {
		result := &InvokeResult{
			StatusCode: 200,
			Payload:    "",
		}
		
		var target map[string]interface{}
		err := ParseInvokeOutputE(result, &target)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "payload is empty")
	})
	
	t.Run("InvalidJSONPayload", func(t *testing.T) {
		result := &InvokeResult{
			StatusCode: 200,
			Payload:    `{"broken": json}`,
		}
		
		var target map[string]interface{}
		err := ParseInvokeOutputE(result, &target)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to unmarshal payload")
	})
}

func TestValidateFunctionName_TDD(t *testing.T) {
	validationScenarios := []struct {
		name         string
		functionName string
		expectError  bool
		errorMessage string
	}{
		{
			name:         "ValidFunctionName",
			functionName: "my-test-function",
			expectError:  false,
		},
		{
			name:         "ValidFunctionNameWithNumbers",
			functionName: "function123",
			expectError:  false,
		},
		{
			name:         "ValidFunctionNameWithUnderscores",
			functionName: "my_test_function",
			expectError:  false,
		},
		{
			name:         "EmptyFunctionName",
			functionName: "",
			expectError:  true,
			errorMessage: "invalid function name",
		},
		{
			name:         "TooLongFunctionName",
			functionName: "this-function-name-is-way-too-long-to-be-valid-in-aws-lambda-and-should-fail-validation",
			expectError:  true,
			errorMessage: "name too long",
		},
		{
			name:         "InvalidCharacters",
			functionName: "function-name-with-!@#",
			expectError:  true,
			errorMessage: "invalid character",
		},
	}
	
	for _, scenario := range validationScenarios {
		t.Run(scenario.name, func(t *testing.T) {
			err := validateFunctionName(scenario.functionName)
			
			if scenario.expectError {
				assert.Error(t, err)
				if scenario.errorMessage != "" {
					assert.Contains(t, err.Error(), scenario.errorMessage)
				}
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidatePayload_TDD(t *testing.T) {
	payloadScenarios := []struct {
		name         string
		payload      string
		expectError  bool
		errorMessage string
	}{
		{
			name:        "ValidJSONPayload",
			payload:     `{"key": "value", "number": 42}`,
			expectError: false,
		},
		{
			name:        "EmptyPayload",
			payload:     "",
			expectError: false, // Empty payload is valid
		},
		{
			name:         "InvalidJSON",
			payload:      `{"invalid": json}`,
			expectError:  true,
			errorMessage: "invalid payload format",
		},
	}
	
	for _, scenario := range payloadScenarios {
		t.Run(scenario.name, func(t *testing.T) {
			err := validatePayload(scenario.payload)
			
			if scenario.expectError {
				assert.Error(t, err)
				if scenario.errorMessage != "" {
					assert.Contains(t, err.Error(), scenario.errorMessage)
				}
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestCalculateBackoffDelay_TDD(t *testing.T) {
	config := RetryConfig{
		MaxAttempts: 5,
		BaseDelay:   1 * time.Second,
		MaxDelay:    30 * time.Second,
		Multiplier:  2.0,
	}
	
	t.Run("ZeroAttempt_ShouldReturnBaseDelay", func(t *testing.T) {
		delay := calculateBackoffDelay(0, config)
		assert.Equal(t, 1*time.Second, delay)
	})
	
	t.Run("ExponentialGrowth", func(t *testing.T) {
		// Attempt 1: 1s * 2^1 = 2s
		delay1 := calculateBackoffDelay(1, config)
		assert.Equal(t, 2*time.Second, delay1)
		
		// Attempt 2: 1s * 2^2 = 4s
		delay2 := calculateBackoffDelay(2, config)
		assert.Equal(t, 4*time.Second, delay2)
	})
	
	t.Run("MaxDelayCapReached", func(t *testing.T) {
		// High attempts should cap at MaxDelay
		delay := calculateBackoffDelay(10, config) // Would be 1024s without cap
		assert.Equal(t, 30*time.Second, delay)
	})
}

func TestSanitizeLogResult_TDD(t *testing.T) {
	t.Run("RemoveRequestIds", func(t *testing.T) {
		input := `START RequestId: abc123-def456-ghi789 Version: $LATEST
INFO	Function executed successfully
RequestId: abc123-def456-ghi789	Function executed
END RequestId: abc123-def456-ghi789`
		
		result := sanitizeLogResult(input)
		
		// Should remove lines containing RequestId but keep the INFO line
		assert.Contains(t, result, "Function executed successfully")
		assert.NotContains(t, result, "RequestId:")
	})
	
	t.Run("EmptyInput", func(t *testing.T) {
		result := sanitizeLogResult("")
		assert.Equal(t, "", result)
	})
	
	t.Run("OnlyUserLogs", func(t *testing.T) {
		input := `INFO	User log message 1
ERROR	User error message`
		
		result := sanitizeLogResult(input)
		
		// Should preserve all user logs
		assert.Contains(t, result, "User log message 1")
		assert.Contains(t, result, "User error message")
	})
}