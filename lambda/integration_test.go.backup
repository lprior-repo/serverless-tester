package lambda

import (
	"context"
	"encoding/json"
	"strings"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs"
	"github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs/types"
	"github.com/aws/aws-sdk-go-v2/service/lambda"
	lambdaTypes "github.com/aws/aws-sdk-go-v2/service/lambda/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// Integration test suite that tests multiple components working together
func TestLambdaWorkflow_CreateInvokeDelete(t *testing.T) {
	// This test simulates a complete Lambda workflow:
	// 1. Create function
	// 2. Wait for it to be active
	// 3. Invoke function
	// 4. Check logs
	// 5. Delete function
	
	// Given: Complete workflow setup
	ctx := createTestContext()
	functionName := "integration-test-function"
	
	// Setup mocks for the entire workflow
	mockClient := &MockLambdaClient{}
	mockLogsClient := &MockCloudWatchLogsClient{}
	
	// Step 1: Create function
	createInput := &lambda.CreateFunctionInput{
		FunctionName: aws.String(functionName),
		Runtime:      lambdaTypes.RuntimeNodejs18x,
		Handler:      aws.String("index.handler"),
		Role:         aws.String("arn:aws:iam::123456789012:role/lambda-role"),
		Code: &lambdaTypes.FunctionCode{
			ZipFile: []byte("fake-zip-content"),
		},
	}
	
	createOutput := &lambda.CreateFunctionOutput{
		FunctionName: aws.String(functionName),
		FunctionArn:  aws.String("arn:aws:lambda:us-east-1:123456789012:function:" + functionName),
		Runtime:      lambdaTypes.RuntimeNodejs18x,
		Handler:      aws.String("index.handler"),
		State:        lambdaTypes.StatePending,
		Version:      aws.String("1"),
	}
	
	mockClient.On("CreateFunction", mock.Anything, createInput, mock.Anything).
		Return(createOutput, nil)
	
	// Step 2: Wait for active - first call returns pending, second returns active
	pendingConfig := createTestFunctionConfiguration(functionName)
	pendingConfig.State = lambdaTypes.StatePending
	activeConfig := createTestFunctionConfiguration(functionName)
	activeConfig.State = lambdaTypes.StateActive
	
	mockClient.On("GetFunction", mock.Anything, mock.AnythingOfType("*lambda.GetFunctionInput"), mock.Anything).
		Return(&lambda.GetFunctionOutput{Configuration: pendingConfig}, nil).Once()
	mockClient.On("GetFunction", mock.Anything, mock.AnythingOfType("*lambda.GetFunctionInput"), mock.Anything).
		Return(&lambda.GetFunctionOutput{Configuration: activeConfig}, nil).Times(2) // Once for wait, once for invoke setup
	
	// Step 3: Invoke function
	invokeOutput := createSuccessfulInvokeOutput(`{"statusCode": 200, "body": "Hello World"}`)
	mockClient.On("Invoke", mock.Anything, mock.AnythingOfType("*lambda.InvokeInput"), mock.Anything).
		Return(invokeOutput, nil)
	
	// Step 4: Check logs
	logEvents := []types.FilteredLogEvent{
		{
			Timestamp: aws.Int64(time.Now().UnixMilli()),
			Message:   aws.String("START RequestId: test-request-id"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 1000),
			Message:   aws.String("INFO Function executed successfully"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 2000),
			Message:   aws.String("END RequestId: test-request-id"),
		},
	}
	
	logsOutput := &cloudwatchlogs.FilterLogEventsOutput{
		Events: logEvents,
	}
	
	mockLogsClient.On("FilterLogEvents", mock.Anything, mock.AnythingOfType("*cloudwatchlogs.FilterLogEventsInput"), mock.Anything).
		Return(logsOutput, nil)
	
	// Step 5: Delete function
	mockClient.On("DeleteFunction", mock.Anything, mock.AnythingOfType("*lambda.DeleteFunctionInput"), mock.Anything).
		Return(&lambda.DeleteFunctionOutput{}, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	originalCreateLogsClient := createCloudWatchLogsClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	createCloudWatchLogsClient = func(*TestContext) *cloudwatchlogs.Client {
		return (*cloudwatchlogs.Client)(mockLogsClient)
	}
	defer func() {
		createLambdaClient = originalCreateClient
		createCloudWatchLogsClient = originalCreateLogsClient
	}()
	
	// When: Executing the complete workflow
	
	// Step 1: Create function
	config, err := CreateFunctionE(ctx, createInput)
	require.NoError(t, err)
	assert.Equal(t, functionName, config.FunctionName)
	assert.Equal(t, lambdaTypes.StatePending, config.State)
	
	// Step 2: Wait for function to be active
	err = WaitForFunctionActiveE(ctx, functionName, 30*time.Second)
	require.NoError(t, err)
	
	// Step 3: Invoke function
	payload := `{"message": "test"}`
	result, err := InvokeE(ctx, functionName, payload)
	require.NoError(t, err)
	assert.Equal(t, int32(200), result.StatusCode)
	assert.Contains(t, result.Payload, "Hello World")
	
	// Step 4: Check logs
	logs, err := GetLogsE(ctx, functionName)
	require.NoError(t, err)
	assert.NotEmpty(t, logs)
	assert.True(t, LogsContain(logs, "Function executed successfully"))
	
	// Step 5: Delete function
	err = DeleteFunctionE(ctx, functionName)
	require.NoError(t, err)
	
	// Then: All operations should have succeeded
	mockClient.AssertExpectations(t)
	mockLogsClient.AssertExpectations(t)
}

func TestEventDrivenWorkflow_S3EventProcessing(t *testing.T) {
	// This test simulates processing an S3 event:
	// 1. Build S3 event
	// 2. Invoke Lambda with S3 event
	// 3. Validate processing logs
	// 4. Assert on payload contents
	
	// Given: S3 event processing setup
	ctx := createTestContext()
	functionName := "s3-processor"
	bucketName := "test-bucket"
	objectKey := "test-file.json"
	
	// Build S3 event
	s3Event, err := BuildS3EventE(bucketName, objectKey, "s3:ObjectCreated:Put")
	require.NoError(t, err)
	
	// Mock Lambda response that processes S3 event
	processedPayload := map[string]interface{}{
		"processedBucket": bucketName,
		"processedKey":    objectKey,
		"status":          "processed",
		"recordsProcessed": 1,
	}
	processedJSON, _ := json.Marshal(processedPayload)
	
	invokeOutput := createSuccessfulInvokeOutput(string(processedJSON))
	
	mockClient := &MockLambdaClient{}
	mockClient.On("Invoke", mock.Anything, mock.MatchedBy(func(input *lambda.InvokeInput) bool {
		// Verify the S3 event structure in the payload
		var event S3Event
		if err := json.Unmarshal(input.Payload, &event); err != nil {
			return false
		}
		return len(event.Records) == 1 &&
			event.Records[0].S3.Bucket.Name == bucketName &&
			event.Records[0].S3.Object.Key == objectKey
	}), mock.Anything).Return(invokeOutput, nil)
	
	// Mock logs showing S3 processing
	logEvents := []types.FilteredLogEvent{
		{
			Timestamp: aws.Int64(time.Now().UnixMilli()),
			Message:   aws.String("START RequestId: s3-request-id"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 500),
			Message:   aws.String("INFO Processing S3 event for bucket: " + bucketName),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 1000),
			Message:   aws.String("INFO Processing object: " + objectKey),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 1500),
			Message:   aws.String("INFO S3 processing completed successfully"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 2000),
			Message:   aws.String("END RequestId: s3-request-id"),
		},
	}
	
	mockLogsClient := &MockCloudWatchLogsClient{}
	mockLogsClient.On("FilterLogEvents", mock.Anything, mock.AnythingOfType("*cloudwatchlogs.FilterLogEventsInput"), mock.Anything).
		Return(&cloudwatchlogs.FilterLogEventsOutput{Events: logEvents}, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	originalCreateLogsClient := createCloudWatchLogsClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	createCloudWatchLogsClient = func(*TestContext) *cloudwatchlogs.Client {
		return (*cloudwatchlogs.Client)(mockLogsClient)
	}
	defer func() {
		createLambdaClient = originalCreateClient
		createCloudWatchLogsClient = originalCreateLogsClient
	}()
	
	// When: Processing S3 event
	result, err := InvokeE(ctx, functionName, s3Event)
	require.NoError(t, err)
	
	// Parse the processed result
	var processedResult map[string]interface{}
	err = ParseInvokeOutputE(result, &processedResult)
	require.NoError(t, err)
	
	// Get processing logs
	logs, err := GetLogsE(ctx, functionName)
	require.NoError(t, err)
	
	// Then: Should have processed the S3 event successfully
	assert.Equal(t, bucketName, processedResult["processedBucket"])
	assert.Equal(t, objectKey, processedResult["processedKey"])
	assert.Equal(t, "processed", processedResult["status"])
	assert.Equal(t, float64(1), processedResult["recordsProcessed"]) // JSON unmarshals numbers as float64
	
	// Verify logs contain expected processing messages
	assert.True(t, LogsContain(logs, "Processing S3 event"))
	assert.True(t, LogsContain(logs, bucketName))
	assert.True(t, LogsContain(logs, objectKey))
	assert.True(t, LogsContain(logs, "processing completed successfully"))
	
	mockClient.AssertExpectations(t)
	mockLogsClient.AssertExpectations(t)
}

func TestEventSourceMappingWorkflow(t *testing.T) {
	// This test simulates managing event source mappings:
	// 1. Create event source mapping
	// 2. Wait for it to be enabled
	// 3. Update mapping configuration
	// 4. List mappings for function
	// 5. Delete mapping
	
	// Given: Event source mapping workflow setup
	ctx := createTestContext()
	functionName := "sqs-consumer"
	queueArn := "arn:aws:sqs:us-east-1:123456789012:test-queue"
	mappingUUID := "12345678-1234-1234-1234-123456789012"
	
	config := EventSourceMappingConfig{
		EventSourceArn:   queueArn,
		FunctionName:     functionName,
		BatchSize:        10,
		StartingPosition: lambdaTypes.EventSourcePositionTrimHorizon,
		Enabled:          true,
	}
	
	mockClient := &MockLambdaClient{}
	
	// Step 1: Create event source mapping
	createOutput := &lambda.CreateEventSourceMappingOutput{
		UUID:           aws.String(mappingUUID),
		EventSourceArn: aws.String(queueArn),
		FunctionArn:    aws.String("arn:aws:lambda:us-east-1:123456789012:function:" + functionName),
		BatchSize:      aws.Int32(10),
		State:          aws.String("Creating"),
	}
	
	mockClient.On("CreateEventSourceMapping", mock.Anything, mock.AnythingOfType("*lambda.CreateEventSourceMappingInput"), mock.Anything).
		Return(createOutput, nil)
	
	// Step 2: Wait for enabled - first call returns Creating, second returns Enabled
	creatingOutput := &lambda.GetEventSourceMappingOutput{
		UUID:           aws.String(mappingUUID),
		EventSourceArn: aws.String(queueArn),
		FunctionArn:    aws.String("arn:aws:lambda:us-east-1:123456789012:function:" + functionName),
		State:          aws.String("Creating"),
		BatchSize:      aws.Int32(10),
	}
	
	enabledOutput := &lambda.GetEventSourceMappingOutput{
		UUID:           aws.String(mappingUUID),
		EventSourceArn: aws.String(queueArn),
		FunctionArn:    aws.String("arn:aws:lambda:us-east-1:123456789012:function:" + functionName),
		State:          aws.String("Enabled"),
		BatchSize:      aws.Int32(10),
	}
	
	mockClient.On("GetEventSourceMapping", mock.Anything, mock.AnythingOfType("*lambda.GetEventSourceMappingInput"), mock.Anything).
		Return(creatingOutput, nil).Once()
	mockClient.On("GetEventSourceMapping", mock.Anything, mock.AnythingOfType("*lambda.GetEventSourceMappingInput"), mock.Anything).
		Return(enabledOutput, nil).Times(2) // Once for wait, once for list setup
	
	// Step 3: Update mapping
	updatedOutput := &lambda.UpdateEventSourceMappingOutput{
		UUID:           aws.String(mappingUUID),
		EventSourceArn: aws.String(queueArn),
		FunctionArn:    aws.String("arn:aws:lambda:us-east-1:123456789012:function:" + functionName),
		State:          aws.String("Enabled"),
		BatchSize:      aws.Int32(20), // Updated batch size
	}
	
	mockClient.On("UpdateEventSourceMapping", mock.Anything, mock.AnythingOfType("*lambda.UpdateEventSourceMappingInput"), mock.Anything).
		Return(updatedOutput, nil)
	
	// Step 4: List mappings
	mappingConfig := &lambdaTypes.EventSourceMappingConfiguration{
		UUID:           aws.String(mappingUUID),
		EventSourceArn: aws.String(queueArn),
		FunctionArn:    aws.String("arn:aws:lambda:us-east-1:123456789012:function:" + functionName),
		State:          aws.String("Enabled"),
		BatchSize:      aws.Int32(20),
	}
	
	listOutput := &lambda.ListEventSourceMappingsOutput{
		EventSourceMappings: []lambdaTypes.EventSourceMappingConfiguration{*mappingConfig},
	}
	
	mockClient.On("ListEventSourceMappings", mock.Anything, mock.AnythingOfType("*lambda.ListEventSourceMappingsInput"), mock.Anything).
		Return(listOutput, nil)
	
	// Step 5: Delete mapping
	deleteOutput := &lambda.DeleteEventSourceMappingOutput{
		UUID:           aws.String(mappingUUID),
		EventSourceArn: aws.String(queueArn),
		FunctionArn:    aws.String("arn:aws:lambda:us-east-1:123456789012:function:" + functionName),
		State:          aws.String("Deleting"),
		BatchSize:      aws.Int32(20),
	}
	
	mockClient.On("DeleteEventSourceMapping", mock.Anything, mock.AnythingOfType("*lambda.DeleteEventSourceMappingInput"), mock.Anything).
		Return(deleteOutput, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Executing event source mapping workflow
	
	// Step 1: Create mapping
	result, err := CreateEventSourceMappingE(ctx, config)
	require.NoError(t, err)
	assert.Equal(t, mappingUUID, result.UUID)
	assert.Equal(t, queueArn, result.EventSourceArn)
	assert.Equal(t, "Creating", result.State)
	
	// Step 2: Wait for enabled
	err = WaitForEventSourceMappingStateE(ctx, mappingUUID, "Enabled", 30*time.Second)
	require.NoError(t, err)
	
	// Step 3: Update mapping
	updateConfig := UpdateEventSourceMappingConfig{
		BatchSize: aws.Int32(20),
	}
	updatedResult, err := UpdateEventSourceMappingE(ctx, mappingUUID, updateConfig)
	require.NoError(t, err)
	assert.Equal(t, int32(20), updatedResult.BatchSize)
	
	// Step 4: List mappings
	mappings, err := ListEventSourceMappingsE(ctx, functionName)
	require.NoError(t, err)
	assert.Len(t, mappings, 1)
	assert.Equal(t, mappingUUID, mappings[0].UUID)
	assert.Equal(t, int32(20), mappings[0].BatchSize)
	
	// Step 5: Delete mapping
	deletedResult, err := DeleteEventSourceMappingE(ctx, mappingUUID)
	require.NoError(t, err)
	assert.Equal(t, mappingUUID, deletedResult.UUID)
	assert.Equal(t, "Deleting", deletedResult.State)
	
	// Then: All operations should have succeeded
	mockClient.AssertExpectations(t)
}

func TestComplexEventProcessing(t *testing.T) {
	// This test simulates processing multiple different event types
	// with the same Lambda function
	
	ctx := createTestContext()
	functionName := "multi-event-processor"
	
	// Test cases for different event types
	testCases := []struct {
		name      string
		eventJSON string
		eventType string
	}{
		{
			"S3 Event",
			BuildS3Event("test-bucket", "file.json", "s3:ObjectCreated:Put"),
			"s3",
		},
		{
			"DynamoDB Event", 
			BuildDynamoDBEvent("test-table", "INSERT", map[string]interface{}{"id": map[string]interface{}{"S": "123"}}),
			"dynamodb",
		},
		{
			"SQS Event",
			BuildSQSEvent("https://sqs.us-east-1.amazonaws.com/123456789012/queue", "Test message"),
			"sqs",
		},
		{
			"SNS Event",
			BuildSNSEvent("arn:aws:sns:us-east-1:123456789012:topic", "Test notification"),
			"sns",
		},
		{
			"API Gateway Event",
			BuildAPIGatewayEvent("POST", "/api/webhook", `{"data":"test"}`),
			"apigateway",
		},
	}
	
	mockClient := &MockLambdaClient{}
	
	// For each event type, mock a successful processing response
	for i, tc := range testCases {
		expectedResponse := map[string]interface{}{
			"eventType": tc.eventType,
			"status":    "processed",
			"timestamp": time.Now().Unix(),
		}
		responseJSON, _ := json.Marshal(expectedResponse)
		invokeOutput := createSuccessfulInvokeOutput(string(responseJSON))
		
		mockClient.On("Invoke", mock.Anything, mock.MatchedBy(func(input *lambda.InvokeInput) bool {
			// Basic validation that we're getting the expected event structure
			payload := string(input.Payload)
			return strings.Contains(payload, "Records") || strings.Contains(payload, "httpMethod")
		}), mock.Anything).Return(invokeOutput, nil).Once()
		
		// Mock logs for each event processing
		logMessage := "INFO Processing " + tc.eventType + " event"
		logEvents := []types.FilteredLogEvent{
			{
				Timestamp: aws.Int64(time.Now().UnixMilli() + int64(i*1000)),
				Message:   aws.String(logMessage),
			},
		}
		
		mockLogsClient := &MockCloudWatchLogsClient{}
		mockLogsClient.On("FilterLogEvents", mock.Anything, mock.AnythingOfType("*cloudwatchlogs.FilterLogEventsInput"), mock.Anything).
			Return(&cloudwatchlogs.FilterLogEventsOutput{Events: logEvents}, nil).Once()
		
		// Mock client creation for this iteration
		originalCreateClient := createLambdaClient
		originalCreateLogsClient := createCloudWatchLogsClient
		createLambdaClient = func(*TestContext) *lambda.Client {
			return (*lambda.Client)(mockClient)
		}
		createCloudWatchLogsClient = func(*TestContext) *cloudwatchlogs.Client {
			return (*cloudwatchlogs.Client)(mockLogsClient)
		}
		
		// Process the event
		result, err := InvokeE(ctx, functionName, tc.eventJSON)
		require.NoError(t, err, "Failed to process %s", tc.name)
		
		// Validate response
		var response map[string]interface{}
		err = ParseInvokeOutputE(result, &response)
		require.NoError(t, err, "Failed to parse response for %s", tc.name)
		
		assert.Equal(t, tc.eventType, response["eventType"], "Wrong event type for %s", tc.name)
		assert.Equal(t, "processed", response["status"], "Wrong status for %s", tc.name)
		
		// Check logs
		logs, err := GetLogsE(ctx, functionName)
		require.NoError(t, err, "Failed to get logs for %s", tc.name)
		assert.True(t, LogsContain(logs, "Processing "+tc.eventType), "Missing log message for %s", tc.name)
		
		mockLogsClient.AssertExpectations(t)
		
		// Restore original functions
		createLambdaClient = originalCreateClient
		createCloudWatchLogsClient = originalCreateLogsClient
	}
	
	mockClient.AssertExpectations(t)
}

func TestFailureRecoveryWorkflow(t *testing.T) {
	// This test simulates failure scenarios and recovery
	// 1. Function fails initially
	// 2. Check error logs
	// 3. Update function to fix issue
	// 4. Retry invocation successfully
	
	ctx := createTestContext()
	functionName := "flaky-function"
	payload := `{"test": "data"}`
	
	mockClient := &MockLambdaClient{}
	
	// Step 1: Initial invocation fails
	errorOutput := createErrorInvokeOutput("Unhandled")
	mockClient.On("Invoke", mock.Anything, mock.AnythingOfType("*lambda.InvokeInput"), mock.Anything).
		Return(errorOutput, nil).Once()
	
	// Error logs
	errorLogEvents := []types.FilteredLogEvent{
		{
			Timestamp: aws.Int64(time.Now().UnixMilli()),
			Message:   aws.String("START RequestId: error-request-id"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 500),
			Message:   aws.String("ERROR Unhandled exception in function"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 1000),
			Message:   aws.String("END RequestId: error-request-id"),
		},
	}
	
	mockLogsClient := &MockCloudWatchLogsClient{}
	mockLogsClient.On("FilterLogEvents", mock.Anything, mock.AnythingOfType("*cloudwatchlogs.FilterLogEventsInput"), mock.Anything).
		Return(&cloudwatchlogs.FilterLogEventsOutput{Events: errorLogEvents}, nil).Once()
	
	// Step 2: Update function configuration
	updateConfig := UpdateFunctionConfig{
		FunctionName: functionName,
		Environment: map[string]string{
			"FIX_APPLIED": "true",
			"LOG_LEVEL":   "debug",
		},
	}
	
	updatedFunctionConfig := createTestFunctionConfiguration(functionName)
	updatedFunctionConfig.Environment["FIX_APPLIED"] = "true"
	updatedFunctionConfig.Environment["LOG_LEVEL"] = "debug"
	
	updateOutput := &lambda.UpdateFunctionConfigurationOutput{
		FunctionName: aws.String(functionName),
		FunctionArn:  updatedFunctionConfig.FunctionArn,
		Runtime:      updatedFunctionConfig.Runtime,
		Handler:      aws.String(updatedFunctionConfig.Handler),
		Environment: &lambdaTypes.Environment{
			Variables: updatedFunctionConfig.Environment,
		},
		State:   lambdaTypes.StateActive,
		Version: aws.String("2"),
	}
	
	mockClient.On("UpdateFunctionConfiguration", mock.Anything, mock.AnythingOfType("*lambda.UpdateFunctionConfigurationInput"), mock.Anything).
		Return(updateOutput, nil)
	
	// Step 3: Retry invocation succeeds
	successOutput := createSuccessfulInvokeOutput(`{"status": "success", "fixed": true}`)
	mockClient.On("Invoke", mock.Anything, mock.AnythingOfType("*lambda.InvokeInput"), mock.Anything).
		Return(successOutput, nil).Once()
	
	// Success logs
	successLogEvents := []types.FilteredLogEvent{
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 2000),
			Message:   aws.String("START RequestId: success-request-id"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 2500),
			Message:   aws.String("DEBUG Fix has been applied"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 3000),
			Message:   aws.String("INFO Function executed successfully"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 3500),
			Message:   aws.String("END RequestId: success-request-id"),
		},
	}
	
	mockLogsClient.On("FilterLogEvents", mock.Anything, mock.AnythingOfType("*cloudwatchlogs.FilterLogEventsInput"), mock.Anything).
		Return(&cloudwatchlogs.FilterLogEventsOutput{Events: successLogEvents}, nil).Once()
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	originalCreateLogsClient := createCloudWatchLogsClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	createCloudWatchLogsClient = func(*TestContext) *cloudwatchlogs.Client {
		return (*cloudwatchlogs.Client)(mockLogsClient)
	}
	defer func() {
		createLambdaClient = originalCreateClient
		createCloudWatchLogsClient = originalCreateLogsClient
	}()
	
	// When: Executing failure recovery workflow
	
	// Step 1: Initial invocation fails
	result, err := InvokeE(ctx, functionName, payload)
	assert.Error(t, err, "Expected initial invocation to fail")
	assert.NotNil(t, result, "Should still get result even on function error")
	assert.Equal(t, "Unhandled", result.FunctionError)
	
	// Check error logs
	errorLogs, err := GetLogsE(ctx, functionName)
	require.NoError(t, err)
	assert.True(t, LogsContain(errorLogs, "ERROR"))
	assert.True(t, LogsContain(errorLogs, "Unhandled exception"))
	
	// Step 2: Update function to fix the issue
	updatedConfig, err := UpdateFunctionE(ctx, updateConfig)
	require.NoError(t, err)
	assert.Equal(t, "true", updatedConfig.Environment["FIX_APPLIED"])
	assert.Equal(t, "debug", updatedConfig.Environment["LOG_LEVEL"])
	
	// Step 3: Retry invocation - should succeed now
	retryResult, err := InvokeE(ctx, functionName, payload)
	require.NoError(t, err)
	assert.Empty(t, retryResult.FunctionError)
	assert.Contains(t, retryResult.Payload, "success")
	
	// Check success logs
	successLogs, err := GetLogsE(ctx, functionName)
	require.NoError(t, err)
	assert.True(t, LogsContain(successLogs, "Fix has been applied"))
	assert.True(t, LogsContain(successLogs, "executed successfully"))
	
	// Then: Recovery workflow should complete successfully
	mockClient.AssertExpectations(t)
	mockLogsClient.AssertExpectations(t)
}

// Test assertion workflow integration
func TestAssertionWorkflowIntegration(t *testing.T) {
	// This test demonstrates using multiple assertions together
	// in a realistic testing scenario
	
	ctx := createTestContext()
	functionName := "assertion-test-function"
	
	// Setup function configuration
	expectedConfig := createTestFunctionConfiguration(functionName)
	expectedConfig.Runtime = lambdaTypes.RuntimePython39
	expectedConfig.Handler = "app.lambda_handler"
	expectedConfig.Timeout = 60
	expectedConfig.MemorySize = 256
	expectedConfig.Environment["ENVIRONMENT"] = "test"
	expectedConfig.Environment["DEBUG"] = "true"
	
	getFunctionOutput := &lambda.GetFunctionOutput{
		Configuration: expectedConfig,
	}
	
	// Setup successful invocation
	successPayload := `{"message": "test completed", "status": "success", "duration": 1.5}`
	invokeOutput := createSuccessfulInvokeOutput(successPayload)
	
	// Setup logs with appropriate levels
	logEvents := []types.FilteredLogEvent{
		{
			Timestamp: aws.Int64(time.Now().UnixMilli()),
			Message:   aws.String("START RequestId: assertion-test-id"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 500),
			Message:   aws.String("INFO Starting test execution"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 1000),
			Message:   aws.String("DEBUG Processing test data"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 1500),
			Message:   aws.String("INFO Test completed successfully"),
		},
		{
			Timestamp: aws.Int64(time.Now().UnixMilli() + 2000),
			Message:   aws.String("END RequestId: assertion-test-id"),
		},
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("GetFunction", mock.Anything, mock.AnythingOfType("*lambda.GetFunctionInput"), mock.Anything).
		Return(getFunctionOutput, nil).Maybe() // May be called multiple times by different assertions
	
	mockClient.On("Invoke", mock.Anything, mock.AnythingOfType("*lambda.InvokeInput"), mock.Anything).
		Return(invokeOutput, nil)
	
	mockLogsClient := &MockCloudWatchLogsClient{}
	mockLogsClient.On("FilterLogEvents", mock.Anything, mock.AnythingOfType("*cloudwatchlogs.FilterLogEventsInput"), mock.Anything).
		Return(&cloudwatchlogs.FilterLogEventsOutput{Events: logEvents}, nil).Maybe() // May be called multiple times
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	originalCreateLogsClient := createCloudWatchLogsClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	createCloudWatchLogsClient = func(*TestContext) *cloudwatchlogs.Client {
		return (*cloudwatchlogs.Client)(mockLogsClient)
	}
	defer func() {
		createLambdaClient = originalCreateClient
		createCloudWatchLogsClient = originalCreateLogsClient
	}()
	
	// When: Running assertion workflow
	
	// Assert function exists and has correct configuration
	AssertFunctionExists(ctx, functionName)
	AssertFunctionRuntime(ctx, functionName, lambdaTypes.RuntimePython39)
	AssertFunctionHandler(ctx, functionName, "app.lambda_handler")
	AssertFunctionTimeout(ctx, functionName, 60)
	AssertFunctionMemorySize(ctx, functionName, 256)
	AssertFunctionState(ctx, functionName, lambdaTypes.StateActive)
	
	// Assert environment variables
	AssertEnvVarExists(ctx, functionName, "ENVIRONMENT")
	AssertEnvVarEquals(ctx, functionName, "ENVIRONMENT", "test")
	AssertEnvVarEquals(ctx, functionName, "DEBUG", "true")
	
	// Invoke function and assert results
	result := Invoke(ctx, functionName, `{"test": "data"}`)
	AssertInvokeSuccess(ctx, result)
	AssertPayloadContains(ctx, result, "test completed")
	AssertPayloadContains(ctx, result, "success")
	AssertExecutionTimeLessThan(ctx, result, 5*time.Second)
	
	// Assert logs contain expected messages and levels
	AssertLogsContain(ctx, functionName, "Starting test execution")
	AssertLogsContain(ctx, functionName, "Test completed successfully")
	AssertLogsContainLevel(ctx, functionName, "INFO")
	AssertLogsContainLevel(ctx, functionName, "DEBUG")
	AssertLogsDoNotContain(ctx, functionName, "ERROR")
	
	// Then: All assertions should pass without errors
	mockClient.AssertExpectations(t)
	mockLogsClient.AssertExpectations(t)
}