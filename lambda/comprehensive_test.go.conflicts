package lambda

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs"
	"github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs/types"
	"github.com/aws/aws-sdk-go-v2/service/lambda"
	lambdaTypes "github.com/aws/aws-sdk-go-v2/service/lambda/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// MockTestingT is a test double for the TestingT interface
type MockTestingT struct {
	mock.Mock
	ErrorMessages []string
	FailCalled    bool
}

func (m *MockTestingT) Errorf(format string, args ...interface{}) {
	m.Called(format, args)
	m.ErrorMessages = append(m.ErrorMessages, fmt.Sprintf(format, args...))
}

func (m *MockTestingT) FailNow() {
	m.Called()
	m.FailCalled = true
}

// MockLambdaClient is a test double for the Lambda client
type MockLambdaClient struct {
	mock.Mock
}

func (m *MockLambdaClient) Invoke(ctx context.Context, input *lambda.InvokeInput, optFns ...func(*lambda.Options)) (*lambda.InvokeOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.InvokeOutput), args.Error(1)
}

func (m *MockLambdaClient) GetFunction(ctx context.Context, input *lambda.GetFunctionInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.GetFunctionOutput), args.Error(1)
}

func (m *MockLambdaClient) CreateFunction(ctx context.Context, input *lambda.CreateFunctionInput, optFns ...func(*lambda.Options)) (*lambda.CreateFunctionOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.CreateFunctionOutput), args.Error(1)
}

func (m *MockLambdaClient) DeleteFunction(ctx context.Context, input *lambda.DeleteFunctionInput, optFns ...func(*lambda.Options)) (*lambda.DeleteFunctionOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.DeleteFunctionOutput), args.Error(1)
}

func (m *MockLambdaClient) UpdateFunctionConfiguration(ctx context.Context, input *lambda.UpdateFunctionConfigurationInput, optFns ...func(*lambda.Options)) (*lambda.UpdateFunctionConfigurationOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.UpdateFunctionConfigurationOutput), args.Error(1)
}

func (m *MockLambdaClient) ListFunctions(ctx context.Context, input *lambda.ListFunctionsInput, optFns ...func(*lambda.Options)) (*lambda.ListFunctionsOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.ListFunctionsOutput), args.Error(1)
}

func (m *MockLambdaClient) CreateEventSourceMapping(ctx context.Context, input *lambda.CreateEventSourceMappingInput, optFns ...func(*lambda.Options)) (*lambda.CreateEventSourceMappingOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.CreateEventSourceMappingOutput), args.Error(1)
}

func (m *MockLambdaClient) GetEventSourceMapping(ctx context.Context, input *lambda.GetEventSourceMappingInput, optFns ...func(*lambda.Options)) (*lambda.GetEventSourceMappingOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.GetEventSourceMappingOutput), args.Error(1)
}

func (m *MockLambdaClient) ListEventSourceMappings(ctx context.Context, input *lambda.ListEventSourceMappingsInput, optFns ...func(*lambda.Options)) (*lambda.ListEventSourceMappingsOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.ListEventSourceMappingsOutput), args.Error(1)
}

func (m *MockLambdaClient) UpdateEventSourceMapping(ctx context.Context, input *lambda.UpdateEventSourceMappingInput, optFns ...func(*lambda.Options)) (*lambda.UpdateEventSourceMappingOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.UpdateEventSourceMappingOutput), args.Error(1)
}

func (m *MockLambdaClient) DeleteEventSourceMapping(ctx context.Context, input *lambda.DeleteEventSourceMappingInput, optFns ...func(*lambda.Options)) (*lambda.DeleteEventSourceMappingOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*lambda.DeleteEventSourceMappingOutput), args.Error(1)
}

// MockCloudWatchLogsClient is a test double for the CloudWatch Logs client
type MockCloudWatchLogsClient struct {
	mock.Mock
}

func (m *MockCloudWatchLogsClient) FilterLogEvents(ctx context.Context, input *cloudwatchlogs.FilterLogEventsInput, optFns ...func(*cloudwatchlogs.Options)) (*cloudwatchlogs.FilterLogEventsOutput, error) {
	args := m.Called(ctx, input, optFns)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*cloudwatchlogs.FilterLogEventsOutput), args.Error(1)
}

// Test data factories for clean test setup
func createTestContext() *TestContext {
	return &TestContext{
		T:         &MockTestingT{},
		AwsConfig: aws.Config{Region: "us-east-1"},
		Region:    "us-east-1",
	}
}

func createSuccessfulInvokeOutput(payload string) *lambda.InvokeOutput {
	return &lambda.InvokeOutput{
		StatusCode:      200,
		Payload:         []byte(payload),
		ExecutedVersion: aws.String("1"),
		LogResult:       aws.String("START RequestId: test-request-id\nEND RequestId: test-request-id"),
	}
}

func createErrorInvokeOutput(functionError string) *lambda.InvokeOutput {
	return &lambda.InvokeOutput{
		StatusCode:      200,
		Payload:         []byte(`{"errorMessage": "Function error", "errorType": "Error"}`),
		ExecutedVersion: aws.String("1"),
		FunctionError:   aws.String(functionError),
		LogResult:       aws.String("START RequestId: test-request-id\nERROR Function error\nEND RequestId: test-request-id"),
	}
}

func createTestFunctionConfiguration(name string) *lambdaTypes.FunctionConfiguration {
	return &lambdaTypes.FunctionConfiguration{
		FunctionName: aws.String(name),
		FunctionArn:  aws.String(fmt.Sprintf("arn:aws:lambda:us-east-1:123456789012:function:%s", name)),
		Runtime:      lambdaTypes.RuntimeNodejs18x,
		Handler:      aws.String("index.handler"),
		Description:  aws.String("Test function"),
		Timeout:      aws.Int32(30),
		MemorySize:   aws.Int32(128),
		LastModified: aws.String("2023-01-01T00:00:00.000+0000"),
		Role:         aws.String("arn:aws:iam::123456789012:role/lambda-role"),
		State:        lambdaTypes.StateActive,
		Version:      aws.String("1"),
		Environment: &lambdaTypes.EnvironmentResponse{
			Variables: map[string]string{
				"NODE_ENV": "test",
				"LOG_LEVEL": "info",
			},
		},
	}
}

func createTestEventSourceMappingConfiguration() *lambdaTypes.EventSourceMappingConfiguration {
	now := time.Now()
	return &lambdaTypes.EventSourceMappingConfiguration{
		UUID:                           aws.String("12345678-1234-1234-1234-123456789012"),
		EventSourceArn:                 aws.String("arn:aws:sqs:us-east-1:123456789012:test-queue"),
		FunctionArn:                    aws.String("arn:aws:lambda:us-east-1:123456789012:function:test-function"),
		LastModified:                   &now,
		LastProcessingResult:           aws.String("OK"),
		State:                          aws.String("Enabled"),
		StateTransitionReason:          aws.String("USER_INITIATED"),
		BatchSize:                      aws.Int32(10),
		MaximumBatchingWindowInSeconds: aws.Int32(5),
		StartingPosition:               lambdaTypes.EventSourcePositionTrimHorizon,
	}
}

func createTestLogEvents() []types.FilteredLogEvent {
	timestamp1 := time.Now().UnixMilli()
	timestamp2 := timestamp1 + 1000
	
	return []types.FilteredLogEvent{
		{
			Timestamp: aws.Int64(timestamp1),
			Message:   aws.String("START RequestId: test-request-id Version: $LATEST"),
		},
		{
			Timestamp: aws.Int64(timestamp2),
			Message:   aws.String("INFO Test log message"),
		},
	}
}

// Test suite for Lambda invocation functionality
func TestInvokeE_Success(t *testing.T) {
	// Given: A valid function name and payload
	ctx := createTestContext()
	functionName := "test-function"
	payload := `{"key": "value"}`
	expectedResult := createSuccessfulInvokeOutput(`{"result": "success"}`)
	
	mockClient := &MockLambdaClient{}
	mockClient.On("Invoke", mock.Anything, mock.MatchedBy(func(input *lambda.InvokeInput) bool {
		return *input.FunctionName == functionName &&
			string(input.Payload) == payload &&
			input.InvocationType == lambdaTypes.InvocationTypeRequestResponse
	}), mock.Anything).Return(expectedResult, nil)
	
	// Mock the client creation (this would require dependency injection in real implementation)
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient) // This is a type assertion hack for testing
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Invoking the function
	result, err := InvokeE(ctx, functionName, payload)
	
	// Then: The invocation should succeed
	require.NoError(t, err)
	assert.NotNil(t, result)
	assert.Equal(t, int32(200), result.StatusCode)
	assert.Equal(t, `{"result": "success"}`, result.Payload)
	assert.Empty(t, result.FunctionError)
	assert.Equal(t, "1", result.ExecutedVersion)
	
	mockClient.AssertExpectations(t)
}

func TestInvokeE_FunctionError(t *testing.T) {
	// Given: A function that will return an error
	ctx := createTestContext()
	functionName := "test-function"
	payload := `{"key": "value"}`
	expectedResult := createErrorInvokeOutput("Unhandled")
	
	mockClient := &MockLambdaClient{}
	mockClient.On("Invoke", mock.Anything, mock.AnythingOfType("*lambda.InvokeInput"), mock.Anything).
		Return(expectedResult, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Invoking the function
	result, err := InvokeE(ctx, functionName, payload)
	
	// Then: The invocation should fail with function error
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "lambda function error")
	assert.NotNil(t, result)
	assert.Equal(t, "Unhandled", result.FunctionError)
	
	mockClient.AssertExpectations(t)
}

func TestInvokeE_InvalidFunctionName(t *testing.T) {
	// Given: An invalid function name
	ctx := createTestContext()
	functionName := ""
	payload := `{"key": "value"}`
	
	// When: Invoking with invalid function name
	result, err := InvokeE(ctx, functionName, payload)
	
	// Then: Should return validation error
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "invalid function name")
	assert.Nil(t, result)
}

func TestInvokeE_InvalidPayload(t *testing.T) {
	// Given: An invalid JSON payload
	ctx := createTestContext()
	functionName := "test-function"
	payload := `{"key": "value"` // Invalid JSON - missing closing brace
	
	// When: Invoking with invalid payload
	result, err := InvokeE(ctx, functionName, payload)
	
	// Then: Should return validation error
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "invalid payload")
	assert.Nil(t, result)
}

func TestInvokeAsyncE_Success(t *testing.T) {
	// Given: A valid async invocation setup
	ctx := createTestContext()
	functionName := "test-function"
	payload := `{"key": "value"}`
	expectedResult := createSuccessfulInvokeOutput("")
	expectedResult.StatusCode = 202 // Async invocation returns 202
	
	mockClient := &MockLambdaClient{}
	mockClient.On("Invoke", mock.Anything, mock.MatchedBy(func(input *lambda.InvokeInput) bool {
		return *input.FunctionName == functionName &&
			input.InvocationType == lambdaTypes.InvocationTypeEvent
	}), mock.Anything).Return(expectedResult, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Invoking async
	result, err := InvokeAsyncE(ctx, functionName, payload)
	
	// Then: Should succeed with 202 status
	require.NoError(t, err)
	assert.NotNil(t, result)
	assert.Equal(t, int32(202), result.StatusCode)
	
	mockClient.AssertExpectations(t)
}

func TestDryRunInvokeE_Success(t *testing.T) {
	// Given: A valid dry run invocation setup
	ctx := createTestContext()
	functionName := "test-function"
	payload := `{"key": "value"}`
	expectedResult := createSuccessfulInvokeOutput("")
	expectedResult.StatusCode = 204 // Dry run returns 204
	
	mockClient := &MockLambdaClient{}
	mockClient.On("Invoke", mock.Anything, mock.MatchedBy(func(input *lambda.InvokeInput) bool {
		return *input.FunctionName == functionName &&
			input.InvocationType == lambdaTypes.InvocationTypeDryRun
	}), mock.Anything).Return(expectedResult, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Performing dry run
	result, err := DryRunInvokeE(ctx, functionName, payload)
	
	// Then: Should succeed with 204 status
	require.NoError(t, err)
	assert.NotNil(t, result)
	assert.Equal(t, int32(204), result.StatusCode)
	
	mockClient.AssertExpectations(t)
}

// Test suite for function management
func TestGetFunctionE_Success(t *testing.T) {
	// Given: A valid function configuration
	ctx := createTestContext()
	functionName := "test-function"
	expectedConfig := createTestFunctionConfiguration(functionName)
	expectedOutput := &lambda.GetFunctionOutput{
		Configuration: expectedConfig,
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("GetFunction", mock.Anything, mock.MatchedBy(func(input *lambda.GetFunctionInput) bool {
		return *input.FunctionName == functionName
	}), mock.Anything).Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Getting function configuration
	config, err := GetFunctionE(ctx, functionName)
	
	// Then: Should return correct configuration
	require.NoError(t, err)
	assert.NotNil(t, config)
	assert.Equal(t, functionName, config.FunctionName)
	assert.Equal(t, lambdaTypes.RuntimeNodejs18x, config.Runtime)
	assert.Equal(t, "index.handler", config.Handler)
	assert.Equal(t, int32(30), config.Timeout)
	assert.Equal(t, int32(128), config.MemorySize)
	assert.Equal(t, lambdaTypes.StateActive, config.State)
	assert.Equal(t, "test", config.Environment["NODE_ENV"])
	
	mockClient.AssertExpectations(t)
}

func TestGetFunctionE_NotFound(t *testing.T) {
	// Given: A function that doesn't exist
	ctx := createTestContext()
	functionName := "non-existent-function"
	expectedError := &lambdaTypes.ResourceNotFoundException{
		Type:    aws.String("User"),
		Message: aws.String("Function not found"),
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("GetFunction", mock.Anything, mock.AnythingOfType("*lambda.GetFunctionInput"), mock.Anything).
		Return(nil, expectedError)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Getting non-existent function
	config, err := GetFunctionE(ctx, functionName)
	
	// Then: Should return error
	assert.Error(t, err)
	assert.Nil(t, config)
	assert.Contains(t, err.Error(), "failed to get function configuration")
	
	mockClient.AssertExpectations(t)
}

func TestFunctionExistsE_True(t *testing.T) {
	// Given: A function that exists
	ctx := createTestContext()
	functionName := "test-function"
	expectedConfig := createTestFunctionConfiguration(functionName)
	expectedOutput := &lambda.GetFunctionOutput{
		Configuration: expectedConfig,
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("GetFunction", mock.Anything, mock.AnythingOfType("*lambda.GetFunctionInput"), mock.Anything).
		Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Checking if function exists
	exists, err := FunctionExistsE(ctx, functionName)
	
	// Then: Should return true
	require.NoError(t, err)
	assert.True(t, exists)
	
	mockClient.AssertExpectations(t)
}

func TestFunctionExistsE_False(t *testing.T) {
	// Given: A function that doesn't exist
	ctx := createTestContext()
	functionName := "non-existent-function"
	expectedError := &lambdaTypes.ResourceNotFoundException{
		Type:    aws.String("User"),
		Message: aws.String("Function not found"),
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("GetFunction", mock.Anything, mock.AnythingOfType("*lambda.GetFunctionInput"), mock.Anything).
		Return(nil, expectedError)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Checking if function exists
	exists, err := FunctionExistsE(ctx, functionName)
	
	// Then: Should return false without error
	require.NoError(t, err)
	assert.False(t, exists)
	
	mockClient.AssertExpectations(t)
}

func TestCreateFunctionE_Success(t *testing.T) {
	// Given: Valid function creation input
	ctx := createTestContext()
	functionName := "test-function"
	input := &lambda.CreateFunctionInput{
		FunctionName: aws.String(functionName),
		Runtime:      lambdaTypes.RuntimeNodejs18x,
		Handler:      aws.String("index.handler"),
		Role:         aws.String("arn:aws:iam::123456789012:role/lambda-role"),
		Code: &lambdaTypes.FunctionCode{
			ZipFile: []byte("fake-zip-content"),
		},
	}
	
	expectedOutput := &lambda.CreateFunctionOutput{
		FunctionName: aws.String(functionName),
		FunctionArn:  aws.String(fmt.Sprintf("arn:aws:lambda:us-east-1:123456789012:function:%s", functionName)),
		Runtime:      lambdaTypes.RuntimeNodejs18x,
		Handler:      aws.String("index.handler"),
		Role:         aws.String("arn:aws:iam::123456789012:role/lambda-role"),
		State:        lambdaTypes.StatePending,
		Version:      aws.String("1"),
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("CreateFunction", mock.Anything, input, mock.Anything).Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Creating function
	config, err := CreateFunctionE(ctx, input)
	
	// Then: Should succeed
	require.NoError(t, err)
	assert.NotNil(t, config)
	assert.Equal(t, functionName, config.FunctionName)
	assert.Equal(t, lambdaTypes.RuntimeNodejs18x, config.Runtime)
	assert.Equal(t, lambdaTypes.StatePending, config.State)
	
	mockClient.AssertExpectations(t)
}

func TestDeleteFunctionE_Success(t *testing.T) {
	// Given: A function to delete
	ctx := createTestContext()
	functionName := "test-function"
	
	mockClient := &MockLambdaClient{}
	mockClient.On("DeleteFunction", mock.Anything, mock.MatchedBy(func(input *lambda.DeleteFunctionInput) bool {
		return *input.FunctionName == functionName
	}), mock.Anything).Return(&lambda.DeleteFunctionOutput{}, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Deleting function
	err := DeleteFunctionE(ctx, functionName)
	
	// Then: Should succeed
	require.NoError(t, err)
	
	mockClient.AssertExpectations(t)
}

// Test suite for utility functions
func TestValidateFunctionName_Valid(t *testing.T) {
	// Given: Valid function names
	testCases := []struct {
		name         string
		functionName string
		expectError  bool
	}{
		{"simple name", "test-function", false},
		{"with numbers", "test123", false},
		{"with underscores", "test_function", false},
		{"with dashes", "test-function-name", false},
		{"mixed characters", "Test_Function-123", false},
		{"empty name", "", true},
		{"too long", strings.Repeat("a", 65), true},
		{"invalid characters", "test@function", true},
		{"spaces", "test function", true},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// When: Validating function name
			err := validateFunctionName(tc.functionName)
			
			// Then: Should match expectation
			if tc.expectError {
				assert.Error(t, err, "Expected error for function name: %s", tc.functionName)
			} else {
				assert.NoError(t, err, "Expected no error for function name: %s", tc.functionName)
			}
		})
	}
}

func TestValidatePayload_Valid(t *testing.T) {
	// Given: Various payload formats
	testCases := []struct {
		name        string
		payload     string
		expectError bool
	}{
		{"empty payload", "", false},
		{"valid JSON object", `{"key": "value"}`, false},
		{"valid JSON array", `[1, 2, 3]`, false},
		{"valid JSON string", `"hello"`, false},
		{"valid JSON number", `42`, false},
		{"valid JSON boolean", `true`, false},
		{"valid JSON null", `null`, false},
		{"invalid JSON", `{"key": "value"`, true},
		{"malformed JSON", `{key: value}`, true},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// When: Validating payload
			err := validatePayload(tc.payload)
			
			// Then: Should match expectation
			if tc.expectError {
				assert.Error(t, err, "Expected error for payload: %s", tc.payload)
			} else {
				assert.NoError(t, err, "Expected no error for payload: %s", tc.payload)
			}
		})
	}
}

func TestMarshalPayloadE_Success(t *testing.T) {
	// Given: Various data structures
	testCases := []struct {
		name     string
		input    interface{}
		expected string
	}{
		{"string", "hello", `"hello"`},
		{"number", 42, "42"},
		{"boolean", true, "true"},
		{"nil", nil, ""},
		{"object", map[string]interface{}{"key": "value"}, `{"key":"value"}`},
		{"array", []int{1, 2, 3}, "[1,2,3]"},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// When: Marshaling payload
			result, err := MarshalPayloadE(tc.input)
			
			// Then: Should succeed and match expected output
			require.NoError(t, err)
			assert.Equal(t, tc.expected, result)
		})
	}
}

func TestParseInvokeOutputE_Success(t *testing.T) {
	// Given: A valid invoke result with JSON payload
	result := &InvokeResult{
		StatusCode: 200,
		Payload:    `{"message": "success", "count": 42}`,
	}
	
	var output struct {
		Message string `json:"message"`
		Count   int    `json:"count"`
	}
	
	// When: Parsing the output
	err := ParseInvokeOutputE(result, &output)
	
	// Then: Should succeed and populate the struct
	require.NoError(t, err)
	assert.Equal(t, "success", output.Message)
	assert.Equal(t, 42, output.Count)
}

func TestParseInvokeOutputE_InvalidJSON(t *testing.T) {
	// Given: An invoke result with invalid JSON
	result := &InvokeResult{
		StatusCode: 200,
		Payload:    `{"message": "success", "count":`,
	}
	
	var output map[string]interface{}
	
	// When: Parsing the invalid JSON
	err := ParseInvokeOutputE(result, &output)
	
	// Then: Should return error
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to unmarshal payload")
}

func TestParseInvokeOutputE_NilResult(t *testing.T) {
	// Given: A nil invoke result
	var result *InvokeResult = nil
	var output map[string]interface{}
	
	// When: Parsing nil result
	err := ParseInvokeOutputE(result, &output)
	
	// Then: Should return error
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "invoke result is nil")
}

// Test retry logic
func TestExecuteInvokeWithRetry_SuccessAfterRetry(t *testing.T) {
	// This test would require more sophisticated mocking
	// For now, we'll test the retry configuration logic
	
	// Given: Default retry configuration
	config := defaultRetryConfig()
	
	// When: Calculating backoff delays
	delay1 := calculateBackoffDelay(0, config)
	delay2 := calculateBackoffDelay(1, config)
	delay3 := calculateBackoffDelay(2, config)
	
	// Then: Should increase exponentially
	assert.Equal(t, config.BaseDelay, delay1)
	assert.Equal(t, config.BaseDelay*time.Duration(config.Multiplier), delay2)
	assert.True(t, delay3 > delay2)
	assert.True(t, delay3 <= config.MaxDelay)
}

func TestIsNonRetryableError_RetryableErrors(t *testing.T) {
	// Given: Retryable errors
	retryableErrors := []error{
		errors.New("Service temporarily unavailable"),
		errors.New("Rate exceeded"),
		errors.New("Internal server error"),
	}
	
	for _, err := range retryableErrors {
		// When: Checking if error is retryable
		isNonRetryable := isNonRetryableError(err)
		
		// Then: Should be retryable (false for non-retryable)
		assert.False(t, isNonRetryable, "Error should be retryable: %v", err)
	}
}

func TestIsNonRetryableError_NonRetryableErrors(t *testing.T) {
	// Given: Non-retryable errors
	nonRetryableErrors := []error{
		errors.New("InvalidParameterValueException: Invalid parameter"),
		errors.New("ResourceNotFoundException: Function not found"),
		errors.New("InvalidRequestContentException: Invalid request"),
		errors.New("RequestTooLargeException: Request too large"),
		errors.New("UnsupportedMediaTypeException: Unsupported media type"),
	}
	
	for _, err := range nonRetryableErrors {
		// When: Checking if error is retryable
		isNonRetryable := isNonRetryableError(err)
		
		// Then: Should be non-retryable (true for non-retryable)
		assert.True(t, isNonRetryable, "Error should be non-retryable: %v", err)
	}
}

// Test suite for CloudWatch logs functionality
func TestGetLogsWithOptionsE_Success(t *testing.T) {
	// Given: Valid log retrieval setup
	ctx := createTestContext()
	functionName := "test-function"
	logEvents := createTestLogEvents()
	expectedOutput := &cloudwatchlogs.FilterLogEventsOutput{
		Events: logEvents,
	}
	
	mockClient := &MockCloudWatchLogsClient{}
	mockClient.On("FilterLogEvents", mock.Anything, mock.MatchedBy(func(input *cloudwatchlogs.FilterLogEventsInput) bool {
		return *input.LogGroupName == "/aws/lambda/test-function"
	}), mock.Anything).Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateLogsClient := createCloudWatchLogsClient
	createCloudWatchLogsClient = func(*TestContext) *cloudwatchlogs.Client {
		return (*cloudwatchlogs.Client)(mockClient)
	}
	defer func() { createCloudWatchLogsClient = originalCreateLogsClient }()
	
	// When: Getting logs
	logs, err := GetLogsWithOptionsE(ctx, functionName, &LogsOptions{
		MaxLines:  10,
		ParseLogs: true,
	})
	
	// Then: Should succeed
	require.NoError(t, err)
	assert.NotEmpty(t, logs)
	assert.Len(t, logs, 2)
	assert.Contains(t, logs[0].Message, "START RequestId")
	assert.Contains(t, logs[1].Message, "INFO Test log message")
	
	mockClient.AssertExpectations(t)
}

func TestGetLogsWithOptionsE_EmptyResult(t *testing.T) {
	// Given: No logs available
	ctx := createTestContext()
	functionName := "test-function"
	expectedOutput := &cloudwatchlogs.FilterLogEventsOutput{
		Events: []types.FilteredLogEvent{},
	}
	
	mockClient := &MockCloudWatchLogsClient{}
	mockClient.On("FilterLogEvents", mock.Anything, mock.AnythingOfType("*cloudwatchlogs.FilterLogEventsInput"), mock.Anything).
		Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateLogsClient := createCloudWatchLogsClient
	createCloudWatchLogsClient = func(*TestContext) *cloudwatchlogs.Client {
		return (*cloudwatchlogs.Client)(mockClient)
	}
	defer func() { createCloudWatchLogsClient = originalCreateLogsClient }()
	
	// When: Getting logs with no results
	logs, err := GetLogsWithOptionsE(ctx, functionName, nil)
	
	// Then: Should succeed with empty result
	require.NoError(t, err)
	assert.Empty(t, logs)
	
	mockClient.AssertExpectations(t)
}

func TestGetLogsWithOptionsE_APIError(t *testing.T) {
	// Given: CloudWatch Logs API error
	ctx := createTestContext()
	functionName := "test-function"
	expectedError := errors.New("ResourceNotFoundException: Log group does not exist")
	
	mockClient := &MockCloudWatchLogsClient{}
	mockClient.On("FilterLogEvents", mock.Anything, mock.AnythingOfType("*cloudwatchlogs.FilterLogEventsInput"), mock.Anything).
		Return(nil, expectedError)
	
	// Mock client creation
	originalCreateLogsClient := createCloudWatchLogsClient
	createCloudWatchLogsClient = func(*TestContext) *cloudwatchlogs.Client {
		return (*cloudwatchlogs.Client)(mockClient)
	}
	defer func() { createCloudWatchLogsClient = originalCreateLogsClient }()
	
	// When: Getting logs with API error
	logs, err := GetLogsWithOptionsE(ctx, functionName, nil)
	
	// Then: Should return error
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to retrieve lambda logs")
	assert.Nil(t, logs)
	
	mockClient.AssertExpectations(t)
}

func TestFilterLogs(t *testing.T) {
	// Given: Log entries with different content
	logs := []LogEntry{
		{Message: "This is an error message", Level: "ERROR"},
		{Message: "This is an info message", Level: "INFO"},
		{Message: "This is another error", Level: "ERROR"},
		{Message: "Debug information", Level: "DEBUG"},
	}
	
	// When: Filtering logs by pattern
	errorLogs := FilterLogs(logs, "error")
	
	// Then: Should return matching entries
	assert.Len(t, errorLogs, 2)
	assert.Contains(t, errorLogs[0].Message, "error")
	assert.Contains(t, errorLogs[1].Message, "error")
}

func TestFilterLogsByLevel(t *testing.T) {
	// Given: Log entries with different levels
	logs := []LogEntry{
		{Message: "Error occurred", Level: "ERROR"},
		{Message: "Information", Level: "INFO"},
		{Message: "Another error", Level: "ERROR"},
		{Message: "Debug info", Level: "DEBUG"},
	}
	
	// When: Filtering logs by level
	errorLogs := FilterLogsByLevel(logs, "ERROR")
	
	// Then: Should return matching entries
	assert.Len(t, errorLogs, 2)
	assert.Equal(t, "ERROR", errorLogs[0].Level)
	assert.Equal(t, "ERROR", errorLogs[1].Level)
}

func TestGetLogStats(t *testing.T) {
	// Given: Log entries with various levels and timestamps
	baseTime := time.Now()
	logs := []LogEntry{
		{Timestamp: baseTime, Message: "Error 1", Level: "ERROR"},
		{Timestamp: baseTime.Add(1 * time.Minute), Message: "Info 1", Level: "INFO"},
		{Timestamp: baseTime.Add(2 * time.Minute), Message: "Error 2", Level: "ERROR"},
		{Timestamp: baseTime.Add(3 * time.Minute), Message: "Debug 1", Level: "DEBUG"},
	}
	
	// When: Getting log statistics
	stats := GetLogStats(logs)
	
	// Then: Should provide correct statistics
	assert.Equal(t, 4, stats.TotalEntries)
	assert.Equal(t, baseTime, stats.EarliestEntry)
	assert.Equal(t, baseTime.Add(3*time.Minute), stats.LatestEntry)
	assert.Equal(t, 3*time.Minute, stats.TimeSpan)
	assert.Equal(t, 2, stats.LevelCounts["ERROR"])
	assert.Equal(t, 1, stats.LevelCounts["INFO"])
	assert.Equal(t, 1, stats.LevelCounts["DEBUG"])
}

func TestExtractRequestID(t *testing.T) {
	// Given: Log messages with various request ID formats
	testCases := []struct {
		name      string
		message   string
		expected  string
	}{
		{"Lambda format", "START RequestId: 12345-abcde Version: $LATEST", "12345-abcde"},
		{"Uppercase format", "REQUEST_ID: test-request-id", "test-request-id"},
		{"Lowercase format", "requestId: another-id", "another-id"},
		{"No request ID", "This is a regular log message", ""},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// When: Extracting request ID
			result := extractRequestID(tc.message)
			
			// Then: Should match expected result
			assert.Equal(t, tc.expected, result)
		})
	}
}

func TestExtractLogLevel(t *testing.T) {
	// Given: Log messages with various level formats
	testCases := []struct {
		name     string
		message  string
		expected string
	}{
		{"Error level", "ERROR: Something went wrong", "ERROR"},
		{"Info level", "INFO: Processing request", "INFO"},
		{"Debug level", "DEBUG: Detailed information", "DEBUG"},
		{"Lambda START", "START RequestId: 12345", "INFO"},
		{"Lambda END", "END RequestId: 12345", "INFO"},
		{"Lambda REPORT", "REPORT RequestId: 12345", "INFO"},
		{"No level", "Regular message without level", ""},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// When: Extracting log level
			result := extractLogLevel(tc.message)
			
			// Then: Should match expected result
			assert.Equal(t, tc.expected, result)
		})
	}
}

// Test suite for Event Source Mapping functionality
func TestCreateEventSourceMappingE_Success(t *testing.T) {
	// Given: Valid event source mapping configuration
	ctx := createTestContext()
	config := EventSourceMappingConfig{
		EventSourceArn:   "arn:aws:sqs:us-east-1:123456789012:test-queue",
		FunctionName:     "test-function",
		BatchSize:        10,
		StartingPosition: lambdaTypes.EventSourcePositionTrimHorizon,
		Enabled:          true,
	}
	
	expectedOutput := &lambda.CreateEventSourceMappingOutput{
		UUID:           aws.String("12345678-1234-1234-1234-123456789012"),
		EventSourceArn: aws.String(config.EventSourceArn),
		FunctionArn:    aws.String("arn:aws:lambda:us-east-1:123456789012:function:test-function"),
		BatchSize:      aws.Int32(config.BatchSize),
		State:          aws.String("Creating"),
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("CreateEventSourceMapping", mock.Anything, mock.MatchedBy(func(input *lambda.CreateEventSourceMappingInput) bool {
		return *input.EventSourceArn == config.EventSourceArn &&
			*input.FunctionName == config.FunctionName &&
			*input.BatchSize == config.BatchSize
	}), mock.Anything).Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Creating event source mapping
	result, err := CreateEventSourceMappingE(ctx, config)
	
	// Then: Should succeed
	require.NoError(t, err)
	assert.NotNil(t, result)
	assert.Equal(t, "12345678-1234-1234-1234-123456789012", result.UUID)
	assert.Equal(t, config.EventSourceArn, result.EventSourceArn)
	assert.Equal(t, "Creating", result.State)
	
	mockClient.AssertExpectations(t)
}

func TestCreateEventSourceMappingE_InvalidConfig(t *testing.T) {
	// Given: Invalid event source mapping configuration
	ctx := createTestContext()
	config := EventSourceMappingConfig{
		EventSourceArn: "", // Invalid - empty
		FunctionName:   "test-function",
	}
	
	// When: Creating with invalid config
	result, err := CreateEventSourceMappingE(ctx, config)
	
	// Then: Should return validation error
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "event source ARN cannot be empty")
	assert.Nil(t, result)
}

func TestGetEventSourceMappingE_Success(t *testing.T) {
	// Given: Valid UUID for existing mapping
	ctx := createTestContext()
	uuid := "12345678-1234-1234-1234-123456789012"
	expectedOutput := &lambda.GetEventSourceMappingOutput{
		UUID:           aws.String(uuid),
		EventSourceArn: aws.String("arn:aws:sqs:us-east-1:123456789012:test-queue"),
		FunctionArn:    aws.String("arn:aws:lambda:us-east-1:123456789012:function:test-function"),
		State:          aws.String("Enabled"),
		BatchSize:      aws.Int32(10),
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("GetEventSourceMapping", mock.Anything, mock.MatchedBy(func(input *lambda.GetEventSourceMappingInput) bool {
		return *input.UUID == uuid
	}), mock.Anything).Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Getting event source mapping
	result, err := GetEventSourceMappingE(ctx, uuid)
	
	// Then: Should succeed
	require.NoError(t, err)
	assert.NotNil(t, result)
	assert.Equal(t, uuid, result.UUID)
	assert.Equal(t, "Enabled", result.State)
	
	mockClient.AssertExpectations(t)
}

func TestListEventSourceMappingsE_Success(t *testing.T) {
	// Given: Function with event source mappings
	ctx := createTestContext()
	functionName := "test-function"
	mappingConfig := createTestEventSourceMappingConfiguration()
	expectedOutput := &lambda.ListEventSourceMappingsOutput{
		EventSourceMappings: []lambdaTypes.EventSourceMappingConfiguration{*mappingConfig},
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("ListEventSourceMappings", mock.Anything, mock.MatchedBy(func(input *lambda.ListEventSourceMappingsInput) bool {
		return *input.FunctionName == functionName
	}), mock.Anything).Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// When: Listing event source mappings
	results, err := ListEventSourceMappingsE(ctx, functionName)
	
	// Then: Should succeed
	require.NoError(t, err)
	assert.NotEmpty(t, results)
	assert.Len(t, results, 1)
	assert.Equal(t, "12345678-1234-1234-1234-123456789012", results[0].UUID)
	
	mockClient.AssertExpectations(t)
}

// Test suite for Event Builder functionality
func TestBuildS3EventE_Success(t *testing.T) {
	// Given: Valid S3 event parameters
	bucketName := "test-bucket"
	objectKey := "test-object.txt"
	eventName := "s3:ObjectCreated:Put"
	
	// When: Building S3 event
	eventJSON, err := BuildS3EventE(bucketName, objectKey, eventName)
	
	// Then: Should create valid S3 event
	require.NoError(t, err)
	assert.NotEmpty(t, eventJSON)
	
	// Validate event structure
	var event S3Event
	err = json.Unmarshal([]byte(eventJSON), &event)
	require.NoError(t, err)
	
	assert.Len(t, event.Records, 1)
	record := event.Records[0]
	assert.Equal(t, eventName, record.EventName)
	assert.Equal(t, "aws:s3", record.EventSource)
	assert.Equal(t, bucketName, record.S3.Bucket.Name)
	assert.Equal(t, objectKey, record.S3.Object.Key)
}

func TestBuildS3EventE_InvalidParameters(t *testing.T) {
	testCases := []struct {
		name        string
		bucketName  string
		objectKey   string
		eventName   string
		expectError bool
	}{
		{"empty bucket", "", "key", "event", true},
		{"empty key", "bucket", "", "event", true},
		{"valid params", "bucket", "key", "event", false},
		{"empty event name", "bucket", "key", "", false}, // Should use default
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// When: Building S3 event
			eventJSON, err := BuildS3EventE(tc.bucketName, tc.objectKey, tc.eventName)
			
			// Then: Should match expectation
			if tc.expectError {
				assert.Error(t, err)
				assert.Empty(t, eventJSON)
			} else {
				assert.NoError(t, err)
				assert.NotEmpty(t, eventJSON)
			}
		})
	}
}

func TestBuildDynamoDBEventE_Success(t *testing.T) {
	// Given: Valid DynamoDB event parameters
	tableName := "test-table"
	eventName := "INSERT"
	keys := map[string]interface{}{
		"id": map[string]interface{}{"S": "test-id"},
	}
	
	// When: Building DynamoDB event
	eventJSON, err := BuildDynamoDBEventE(tableName, eventName, keys)
	
	// Then: Should create valid DynamoDB event
	require.NoError(t, err)
	assert.NotEmpty(t, eventJSON)
	
	// Validate event structure
	var event DynamoDBEvent
	err = json.Unmarshal([]byte(eventJSON), &event)
	require.NoError(t, err)
	
	assert.Len(t, event.Records, 1)
	record := event.Records[0]
	assert.Equal(t, eventName, record.EventName)
	assert.Equal(t, "aws:dynamodb", record.EventSource)
	assert.NotNil(t, record.Dynamodb.Keys)
}

func TestBuildSQSEventE_Success(t *testing.T) {
	// Given: Valid SQS event parameters
	queueUrl := "https://sqs.us-east-1.amazonaws.com/123456789012/test-queue"
	messageBody := "Hello from SQS"
	
	// When: Building SQS event
	eventJSON, err := BuildSQSEventE(queueUrl, messageBody)
	
	// Then: Should create valid SQS event
	require.NoError(t, err)
	assert.NotEmpty(t, eventJSON)
	
	// Validate event structure
	var event SQSEvent
	err = json.Unmarshal([]byte(eventJSON), &event)
	require.NoError(t, err)
	
	assert.Len(t, event.Records, 1)
	record := event.Records[0]
	assert.Equal(t, messageBody, record.Body)
	assert.Equal(t, "aws:sqs", record.EventSource)
	assert.Equal(t, queueUrl, record.EventSourceARN)
}

func TestBuildSNSEventE_Success(t *testing.T) {
	// Given: Valid SNS event parameters
	topicArn := "arn:aws:sns:us-east-1:123456789012:test-topic"
	message := "Hello from SNS"
	
	// When: Building SNS event
	eventJSON, err := BuildSNSEventE(topicArn, message)
	
	// Then: Should create valid SNS event
	require.NoError(t, err)
	assert.NotEmpty(t, eventJSON)
	
	// Validate event structure
	var event SNSEvent
	err = json.Unmarshal([]byte(eventJSON), &event)
	require.NoError(t, err)
	
	assert.Len(t, event.Records, 1)
	record := event.Records[0]
	assert.Equal(t, message, record.Sns.Message)
	assert.Equal(t, "aws:sns", record.EventSource)
	assert.Equal(t, topicArn, record.Sns.TopicArn)
}

func TestBuildAPIGatewayEventE_Success(t *testing.T) {
	// Given: Valid API Gateway event parameters
	httpMethod := "POST"
	path := "/api/test"
	body := `{"key": "value"}`
	
	// When: Building API Gateway event
	eventJSON, err := BuildAPIGatewayEventE(httpMethod, path, body)
	
	// Then: Should create valid API Gateway event
	require.NoError(t, err)
	assert.NotEmpty(t, eventJSON)
	
	// Validate event structure
	var event APIGatewayEvent
	err = json.Unmarshal([]byte(eventJSON), &event)
	require.NoError(t, err)
	
	assert.Equal(t, httpMethod, event.HttpMethod)
	assert.Equal(t, path, event.Path)
	assert.Equal(t, body, event.Body)
	assert.NotNil(t, event.RequestContext)
}

func TestValidateEventStructure(t *testing.T) {
	// Given: Various event types and structures
	testCases := []struct {
		name       string
		eventJSON  string
		eventType  string
		expectErrors bool
	}{
		{
			"valid S3 event",
			`{"Records": [{"eventSource": "aws:s3", "s3": {"bucket": {"name": "test"}, "object": {"key": "test.txt"}}}]}`,
			"s3",
			false,
		},
		{
			"invalid S3 event",
			`{"Records": []}`,
			"s3",
			true,
		},
		{
			"valid DynamoDB event",
			`{"Records": [{"eventSource": "aws:dynamodb", "dynamodb": {"Keys": {"id": {"S": "test"}}}}]}`,
			"dynamodb",
			false,
		},
		{
			"invalid DynamoDB event",
			`{"Records": [{"eventSource": "aws:sqs"}]}`,
			"dynamodb",
			true,
		},
		{
			"unknown event type",
			`{"Records": []}`,
			"unknown",
			true,
		},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// When: Validating event structure
			errors := ValidateEventStructure(tc.eventJSON, tc.eventType)
			
			// Then: Should match expectation
			if tc.expectErrors {
				assert.NotEmpty(t, errors, "Expected validation errors for %s", tc.name)
			} else {
				assert.Empty(t, errors, "Expected no validation errors for %s", tc.name)
			}
		})
	}
}

// Test suite for Assertion functionality
func TestAssertFunctionExists_Success(t *testing.T) {
	// Given: Function that exists
	ctx := createTestContext()
	functionName := "test-function"
	expectedConfig := createTestFunctionConfiguration(functionName)
	expectedOutput := &lambda.GetFunctionOutput{
		Configuration: expectedConfig,
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("GetFunction", mock.Anything, mock.AnythingOfType("*lambda.GetFunctionInput"), mock.Anything).
		Return(expectedOutput, nil)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// Mock TestingT to capture calls
	mockT := &MockTestingT{}
	ctx.T = mockT
	
	// When: Asserting function exists
	AssertFunctionExists(ctx, functionName)
	
	// Then: Should not call Errorf or FailNow
	assert.Empty(t, mockT.ErrorMessages)
	assert.False(t, mockT.FailCalled)
	
	mockClient.AssertExpectations(t)
}

func TestAssertFunctionExists_NotFound(t *testing.T) {
	// Given: Function that doesn't exist
	ctx := createTestContext()
	functionName := "non-existent-function"
	expectedError := &lambdaTypes.ResourceNotFoundException{
		Type:    aws.String("User"),
		Message: aws.String("Function not found"),
	}
	
	mockClient := &MockLambdaClient{}
	mockClient.On("GetFunction", mock.Anything, mock.AnythingOfType("*lambda.GetFunctionInput"), mock.Anything).
		Return(nil, expectedError)
	
	// Mock client creation
	originalCreateClient := createLambdaClient
	createLambdaClient = func(*TestContext) *lambda.Client {
		return (*lambda.Client)(mockClient)
	}
	defer func() { createLambdaClient = originalCreateClient }()
	
	// Mock TestingT to capture calls
	mockT := &MockTestingT{}
	mockT.On("Errorf", mock.AnythingOfType("string"), mock.Anything).Return()
	mockT.On("FailNow").Return()
	ctx.T = mockT
	
	// When: Asserting function exists
	AssertFunctionExists(ctx, functionName)
	
	// Then: Should call Errorf and FailNow
	mockT.AssertCalled(t, "Errorf", "Expected Lambda function '%s' to exist, but it does not", functionName)
	mockT.AssertCalled(t, "FailNow")
	
	mockClient.AssertExpectations(t)
}

func TestAssertInvokeSuccess_Success(t *testing.T) {
	// Given: Successful invoke result
	ctx := createTestContext()
	result := &InvokeResult{
		StatusCode:    200,
		Payload:       `{"result": "success"}`,
		FunctionError: "",
	}
	
	// Mock TestingT to capture calls
	mockT := &MockTestingT{}
	ctx.T = mockT
	
	// When: Asserting invoke success
	AssertInvokeSuccess(ctx, result)
	
	// Then: Should not call Errorf or FailNow
	assert.Empty(t, mockT.ErrorMessages)
	assert.False(t, mockT.FailCalled)
}

func TestAssertInvokeSuccess_WithError(t *testing.T) {
	// Given: Failed invoke result
	ctx := createTestContext()
	result := &InvokeResult{
		StatusCode:    200,
		Payload:       `{"errorMessage": "Function failed"}`,
		FunctionError: "Unhandled",
	}
	
	// Mock TestingT to capture calls
	mockT := &MockTestingT{}
	mockT.On("Errorf", mock.AnythingOfType("string"), mock.Anything).Return()
	mockT.On("FailNow").Return()
	ctx.T = mockT
	
	// When: Asserting invoke success
	AssertInvokeSuccess(ctx, result)
	
	// Then: Should call Errorf and FailNow
	mockT.AssertCalled(t, "Errorf", "Expected successful invocation, but got function error: %s", "Unhandled")
	mockT.AssertCalled(t, "FailNow")
}

func TestAssertPayloadContains_Success(t *testing.T) {
	// Given: Payload that contains expected text
	ctx := createTestContext()
	result := &InvokeResult{
		StatusCode: 200,
		Payload:    `{"message": "success", "data": "test"}`,
	}
	
	// Mock TestingT to capture calls
	mockT := &MockTestingT{}
	ctx.T = mockT
	
	// When: Asserting payload contains text
	AssertPayloadContains(ctx, result, "success")
	
	// Then: Should not call Errorf or FailNow
	assert.Empty(t, mockT.ErrorMessages)
	assert.False(t, mockT.FailCalled)
}

func TestAssertPayloadContains_Missing(t *testing.T) {
	// Given: Payload that doesn't contain expected text
	ctx := createTestContext()
	result := &InvokeResult{
		StatusCode: 200,
		Payload:    `{"message": "failure", "data": "test"}`,
	}
	
	// Mock TestingT to capture calls
	mockT := &MockTestingT{}
	mockT.On("Errorf", mock.AnythingOfType("string"), mock.Anything, mock.Anything).Return()
	mockT.On("FailNow").Return()
	ctx.T = mockT
	
	// When: Asserting payload contains text
	AssertPayloadContains(ctx, result, "success")
	
	// Then: Should call Errorf and FailNow
	mockT.AssertCalled(t, "Errorf", "Expected payload to contain '%s', but payload was: %s", "success", result.Payload)
	mockT.AssertCalled(t, "FailNow")
}

func TestValidateFunctionConfiguration(t *testing.T) {
	// Given: Function configurations to validate
	actual := &FunctionConfiguration{
		FunctionName: "test-function",
		Runtime:      lambdaTypes.RuntimeNodejs18x,
		Handler:      "index.handler",
		Timeout:      30,
		MemorySize:   128,
		Environment:  map[string]string{"NODE_ENV": "test"},
	}
	
	expected := &FunctionConfiguration{
		FunctionName: "test-function",
		Runtime:      lambdaTypes.RuntimeNodejs18x,
		Handler:      "index.handler",
		Timeout:      30,
		MemorySize:   128,
		Environment:  map[string]string{"NODE_ENV": "test"},
	}
	
	// When: Validating matching configurations
	errors := ValidateFunctionConfiguration(actual, expected)
	
	// Then: Should have no errors
	assert.Empty(t, errors)
}

func TestValidateFunctionConfiguration_Mismatches(t *testing.T) {
	// Given: Mismatched function configurations
	actual := &FunctionConfiguration{
		FunctionName: "test-function",
		Runtime:      lambdaTypes.RuntimePython39,
		Handler:      "app.handler",
		Timeout:      60,
		MemorySize:   256,
		Environment:  map[string]string{"NODE_ENV": "prod"},
	}
	
	expected := &FunctionConfiguration{
		FunctionName: "test-function",
		Runtime:      lambdaTypes.RuntimeNodejs18x,
		Handler:      "index.handler",
		Timeout:      30,
		MemorySize:   128,
		Environment:  map[string]string{"NODE_ENV": "test"},
	}
	
	// When: Validating mismatched configurations
	errors := ValidateFunctionConfiguration(actual, expected)
	
	// Then: Should have multiple errors
	assert.NotEmpty(t, errors)
	assert.Contains(t, strings.Join(errors, " "), "expected runtime")
	assert.Contains(t, strings.Join(errors, " "), "expected handler")
	assert.Contains(t, strings.Join(errors, " "), "expected timeout")
	assert.Contains(t, strings.Join(errors, " "), "expected memory size")
	assert.Contains(t, strings.Join(errors, " "), "expected env var")
}

func TestValidateInvokeResult(t *testing.T) {
	// Given: Successful invoke result
	result := &InvokeResult{
		StatusCode:    200,
		Payload:       `{"message": "success"}`,
		FunctionError: "",
	}
	
	// When: Validating for success with payload content
	errors := ValidateInvokeResult(result, true, "success")
	
	// Then: Should have no errors
	assert.Empty(t, errors)
}

func TestValidateInvokeResult_Failure(t *testing.T) {
	// Given: Failed invoke result
	result := &InvokeResult{
		StatusCode:    200,
		Payload:       `{"errorMessage": "Function failed"}`,
		FunctionError: "Unhandled",
	}
	
	// When: Validating expecting success
	errors := ValidateInvokeResult(result, true, "success")
	
	// Then: Should have errors
	assert.NotEmpty(t, errors)
	assert.Contains(t, strings.Join(errors, " "), "expected success but got function error")
	assert.Contains(t, strings.Join(errors, " "), "expected payload to contain")
}

// Benchmark tests for performance validation
func BenchmarkMarshalPayload(b *testing.B) {
	payload := map[string]interface{}{
		"key1": "value1",
		"key2": 42,
		"key3": true,
		"key4": []string{"a", "b", "c"},
	}
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = MarshalPayloadE(payload)
	}
}

func BenchmarkValidateFunctionName(b *testing.B) {
	functionName := "test-function-with-long-name"
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = validateFunctionName(functionName)
	}
}

func BenchmarkValidatePayload(b *testing.B) {
	payload := `{"key": "value", "number": 42, "array": [1, 2, 3]}`
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = validatePayload(payload)
	}
}