{"stats":{"totalMutantsCount":53,"killedCount":53,"notCoveredCount":0,"escapedCount":0,"errorCount":0,"skippedCount":0,"timeOutCount":0,"msi":1,"mutationCodeCoverage":0,"coveredCodeMsi":0},"escaped":null,"timeouted":null,"killed":[{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" - name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -115,7 +115,7 @@\n \n \t// Step 2: Add prefix to each name\n \tprefixed := lo.Map(filtered, func(name string, _ int) string {\n-\t\treturn \"processed_\" + name\n+\t\treturn \"processed_\" - name\n \t})\n \n \t// Step 3: Count results\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.0\" with checksum 6861bfe98886aae8c7637e445a2df9d2\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10/time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -152,7 +152,7 @@\n func main() {\n \t// This main function tests all our functions\n \tconfigs := []TestConfig{\n-\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n+\t\tcreateTestConfig(\"test1\", 10/time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.1\" with checksum da55bce577da815138fc5faa1f89a519\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20/time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -153,7 +153,7 @@\n \t// This main function tests all our functions\n \tconfigs := []TestConfig{\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n-\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n+\t\tcreateTestConfig(\"test2\", 20/time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n \t}\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.2\" with checksum d7bd1fcdc2882ed9959c36bbd600cdf4\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30/time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -154,7 +154,7 @@\n \tconfigs := []TestConfig{\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n-\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n+\t\tcreateTestConfig(\"\", 30/time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n \t}\n \n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.3\" with checksum c57f35a3fa972e0a7707ccfe9503c573\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40/time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -155,7 +155,7 @@\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n-\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n+\t\tcreateTestConfig(\"test3\", 40/time.Second, true),\n \t}\n \n \tvalidConfigs := filterValidConfigs(configs)\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.4\" with checksum a98b742255b763360ee82328ce64e7b6\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\t_, _, _, _, _ = data, mo.None, error, mo.Some, fmt.Errorf\n\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -53,10 +53,8 @@\n \n func processConfig(config TestConfig) *TestResult {\n \tif !validateConfig(config) {\n-\t\treturn \u0026TestResult{\n-\t\t\tdata:  mo.None[interface{}](),\n-\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n-\t\t}\n+\t\t_, _, _, _, _ = data, mo.None, error, mo.Some, fmt.Errorf\n+\n \t}\n \n \tprocessedData := map[string]interface{}{\n@@ -134,7 +132,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +161,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.5\" with checksum 48fcb279ea48beec582528a3554246c1\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\t_, _, _, _, _ = data, mo.Some, data, error, mo.None\n\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -86,10 +86,8 @@\n \n func createResult(success bool, data interface{}, err error) *TestResult {\n \tif success {\n-\t\treturn \u0026TestResult{\n-\t\t\tdata:  mo.Some[interface{}](data),\n-\t\t\terror: mo.None[error](),\n-\t\t}\n+\t\t_, _, _, _, _ = data, mo.Some, data, error, mo.None\n+\n \t}\n \treturn \u0026TestResult{\n \t\tdata:  mo.None[interface{}](),\n@@ -134,7 +132,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +161,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.6\" with checksum 5731cc469d76242431ae20905d660837\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -101,7 +101,7 @@\n func processNamesPipeline(names []string) int {\n \t// This function has multiple steps that can be mutated\n \tif len(names) == 0 {\n-\t\treturn 0\n+\n \t}\n \n \t// Step 1: Filter out empty strings\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.7\" with checksum 9fe67a223cdcadf82d936dd1c5c1a011\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -110,7 +110,7 @@\n \t})\n \n \tif len(filtered) == 0 {\n-\t\treturn 0\n+\n \t}\n \n \t// Step 2: Add prefix to each name\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.8\" with checksum 1af75fcdc890f19e466cbfe080285b45\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\t_, _ = fmt.Errorf, minSize\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -125,7 +125,7 @@\n // Complex function with multiple conditional branches for mutation testing\n func validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n \tif len(configs) \u003c minSize {\n-\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n+\t\t_, _ = fmt.Errorf, minSize\n \t}\n \n \tvalidCount := 0\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.9\" with checksum 9c49a26566d47ce2a1e0e49893ed61e4\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\t_, _, _, _, _ = validCount, result, config, result.IsSuccess, processedCount\n\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -133,12 +133,8 @@\n \n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n-\t\t\tvalidCount++\n-\t\t\t\n-\t\t\tresult := processConfig(config)\n-\t\t\tif result.IsSuccess() {\n-\t\t\t\tprocessedCount++\n-\t\t\t}\n+\t\t\t_, _, _, _, _ = validCount, result, config, result.IsSuccess, processedCount\n+\n \t\t}\n \t}\n \n@@ -163,13 +159,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.10\" with checksum d3daaef88e7ff88bee16b9dfddf8d974\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\t_ = processedCount\n\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,10 +134,11 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n-\t\t\t\tprocessedCount++\n+\t\t\t\t_ = processedCount\n+\n \t\t\t}\n \t\t}\n \t}\n@@ -163,13 +164,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.11\" with checksum 0680e8ce22b69d38c167e41c7902ca62\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\t_ = fmt.Errorf\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -143,7 +143,7 @@\n \t}\n \n \tif processedCount == 0 {\n-\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n+\t\t_ = fmt.Errorf\n \t}\n \n \treturn processedCount, nil\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.12\" with checksum ead7f7ea583399f6c04b5835e97e7b33\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\t_, _ = fmt.Printf, err\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n-\t\tfmt.Printf(\"Error: %v\\n\", err)\n+\t\t_, _ = fmt.Printf, err\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.13\" with checksum 12972394a78d1273089257715c18060e\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e= 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -42,7 +42,7 @@\n }\n \n func validateConfig(config TestConfig) bool {\n-\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n+\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e= 0\n }\n \n func filterValidConfigs(configs []TestConfig) []TestConfig {\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.14\" with checksum 4d26f2d22a76be68dacf2d065be52abb\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c= minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -124,7 +124,7 @@\n \n // Complex function with multiple conditional branches for mutation testing\n func validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n-\tif len(configs) \u003c minSize {\n+\tif len(configs) \u003c= minSize {\n \t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n \t}\n \n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.15\" with checksum 09f3b769ed6d616cdbd2d753b62aa961\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn true \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -21,7 +21,7 @@\n }\n \n func (r *TestResult) IsSuccess() bool {\n-\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n+\treturn true \u0026\u0026 r.error.IsAbsent()\n }\n \n func (r *TestResult) GetData() mo.Option[interface{}] {\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.16\" with checksum 30f565e06c41de3e6c5ff2dccb460d29\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 true\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -21,7 +21,7 @@\n }\n \n func (r *TestResult) IsSuccess() bool {\n-\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n+\treturn r.data.IsPresent() \u0026\u0026 true\n }\n \n func (r *TestResult) GetData() mo.Option[interface{}] {\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.17\" with checksum 2e95ef012f359e1dd9f529ca69697b40\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn true \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -42,7 +42,7 @@\n }\n \n func validateConfig(config TestConfig) bool {\n-\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n+\treturn true \u0026\u0026 config.timeout \u003e 0\n }\n \n func filterValidConfigs(configs []TestConfig) []TestConfig {\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.18\" with checksum 1fdd831aa8a09d7ed5e97fcac9740e05\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 true\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -42,7 +42,7 @@\n }\n \n func validateConfig(config TestConfig) bool {\n-\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n+\treturn config.name != \"\" \u0026\u0026 true\n }\n \n func filterValidConfigs(configs []TestConfig) []TestConfig {\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.19\" with checksum 6ec263201bd7052106526c313e19d7cd\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tbreak\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -132,9 +132,10 @@\n \tprocessedCount := 0\n \n \tfor _, config := range configs {\n+\t\tbreak\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +164,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.20\" with checksum 86fe47bae977cadb384f27907b8bc77e\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e -1\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -42,7 +42,7 @@\n }\n \n func validateConfig(config TestConfig) bool {\n-\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n+\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e -1\n }\n \n func filterValidConfigs(configs []TestConfig) []TestConfig {\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.21\" with checksum e4e20aac5d2344866a684c6ef922c5bd\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == -1 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -100,7 +100,7 @@\n // Critical function for mutation testing - this has conditional logic that should be tested\n func processNamesPipeline(names []string) int {\n \t// This function has multiple steps that can be mutated\n-\tif len(names) == 0 {\n+\tif len(names) == -1 {\n \t\treturn 0\n \t}\n \n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.22\" with checksum adec670c3da686ba1d0d7bf3e9603e29\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn -1\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -101,7 +101,7 @@\n func processNamesPipeline(names []string) int {\n \t// This function has multiple steps that can be mutated\n \tif len(names) == 0 {\n-\t\treturn 0\n+\t\treturn -1\n \t}\n \n \t// Step 1: Filter out empty strings\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.23\" with checksum ee5372c8718a37464aa5b1a58fe58687\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == -1 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -109,7 +109,7 @@\n \t\treturn name != \"\"\n \t})\n \n-\tif len(filtered) == 0 {\n+\tif len(filtered) == -1 {\n \t\treturn 0\n \t}\n \n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.24\" with checksum 1f9b99e3b853517470331b7d085da170\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn -1\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -110,7 +110,7 @@\n \t})\n \n \tif len(filtered) == 0 {\n-\t\treturn 0\n+\t\treturn -1\n \t}\n \n \t// Step 2: Add prefix to each name\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.25\" with checksum 27e15016e138cacb4ade3a60b56f50c5\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn -1, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -125,7 +125,7 @@\n // Complex function with multiple conditional branches for mutation testing\n func validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n \tif len(configs) \u003c minSize {\n-\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n+\t\treturn -1, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n \t}\n \n \tvalidCount := 0\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.26\" with checksum 4f9454a0415670e3046610f1ee56fbd9\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := -1\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -128,13 +128,13 @@\n \t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n \t}\n \n-\tvalidCount := 0\n+\tvalidCount := -1\n \tprocessedCount := 0\n \n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.27\" with checksum 194fc009ea23721527ec2407944f6ae3\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := -1\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -129,12 +129,12 @@\n \t}\n \n \tvalidCount := 0\n-\tprocessedCount := 0\n+\tprocessedCount := -1\n \n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.28\" with checksum 10be1932becee1c73900c8b6ff24c6eb\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == -1 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -142,7 +142,7 @@\n \t\t}\n \t}\n \n-\tif processedCount == 0 {\n+\tif processedCount == -1 {\n \t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n \t}\n \n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.29\" with checksum e882ffe15a038b7a33bc85c8546b6fc9\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn -1, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -143,7 +143,7 @@\n \t}\n \n \tif processedCount == 0 {\n-\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n+\t\treturn -1, fmt.Errorf(\"no configurations were successfully processed\")\n \t}\n \n \treturn processedCount, nil\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.30\" with checksum 267510bdbc87f03d542938a249eff5b5\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 9*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -152,7 +152,7 @@\n func main() {\n \t// This main function tests all our functions\n \tconfigs := []TestConfig{\n-\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n+\t\tcreateTestConfig(\"test1\", 9*time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.31\" with checksum bc8da2ebbd208d56f46a60bc277ef5f9\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 19*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -153,7 +153,7 @@\n \t// This main function tests all our functions\n \tconfigs := []TestConfig{\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n-\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n+\t\tcreateTestConfig(\"test2\", 19*time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n \t}\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.32\" with checksum 847bec9ac23847b2646e7b0b474de157\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 29*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -154,7 +154,7 @@\n \tconfigs := []TestConfig{\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n-\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n+\t\tcreateTestConfig(\"\", 29*time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n \t}\n \n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.33\" with checksum 0c0e082e8c6cb195f2586b7a4e4b0e5b\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 39*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -155,7 +155,7 @@\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n-\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n+\t\tcreateTestConfig(\"test3\", 39*time.Second, true),\n \t}\n \n \tvalidConfigs := filterValidConfigs(configs)\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.34\" with checksum 7c5ca8e0f68f36b80d97de8950457157\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 1)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -162,14 +162,14 @@\n \tresults := processConfigs(validConfigs)\n \tsuccessCount := countSuccessful(results)\n \n-\tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\tprocessed, err := validateAndProcessBatch(configs, 1)\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.35\" with checksum 29ea8e0bdabf7ea58478b85c73352bb6\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 1\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -42,7 +42,7 @@\n }\n \n func validateConfig(config TestConfig) bool {\n-\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n+\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 1\n }\n \n func filterValidConfigs(configs []TestConfig) []TestConfig {\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.36\" with checksum 7cf54b7abd06f05268bc9b17732ef625\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 1 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -100,7 +100,7 @@\n // Critical function for mutation testing - this has conditional logic that should be tested\n func processNamesPipeline(names []string) int {\n \t// This function has multiple steps that can be mutated\n-\tif len(names) == 0 {\n+\tif len(names) == 1 {\n \t\treturn 0\n \t}\n \n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.37\" with checksum 9b9a8d0d651cb5f9f9667e615705cda2\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 1\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -101,7 +101,7 @@\n func processNamesPipeline(names []string) int {\n \t// This function has multiple steps that can be mutated\n \tif len(names) == 0 {\n-\t\treturn 0\n+\t\treturn 1\n \t}\n \n \t// Step 1: Filter out empty strings\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.38\" with checksum 763ddda75563900920f6d4e8533f614b\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 1 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -109,7 +109,7 @@\n \t\treturn name != \"\"\n \t})\n \n-\tif len(filtered) == 0 {\n+\tif len(filtered) == 1 {\n \t\treturn 0\n \t}\n \n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.39\" with checksum 9b03599c007b291c01b4af0ed987f5db\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 1\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -110,7 +110,7 @@\n \t})\n \n \tif len(filtered) == 0 {\n-\t\treturn 0\n+\t\treturn 1\n \t}\n \n \t// Step 2: Add prefix to each name\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.40\" with checksum 03dd76fbeb79ddfe5e16a6ba0425b2a5\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 1, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -125,7 +125,7 @@\n // Complex function with multiple conditional branches for mutation testing\n func validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n \tif len(configs) \u003c minSize {\n-\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n+\t\treturn 1, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n \t}\n \n \tvalidCount := 0\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.41\" with checksum 126565a40b815a3245ec42bad213c525\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 1\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -128,13 +128,13 @@\n \t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n \t}\n \n-\tvalidCount := 0\n+\tvalidCount := 1\n \tprocessedCount := 0\n \n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.42\" with checksum c99f231b70896a5fb2e6a524e519252c\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 1\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -129,12 +129,12 @@\n \t}\n \n \tvalidCount := 0\n-\tprocessedCount := 0\n+\tprocessedCount := 1\n \n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.43\" with checksum bb176d301a6f965c495cd91a4682e991\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 1 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -142,7 +142,7 @@\n \t\t}\n \t}\n \n-\tif processedCount == 0 {\n+\tif processedCount == 1 {\n \t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n \t}\n \n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.44\" with checksum c2fdd7fe81079d9648e4e26065b1be10\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 1, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -143,7 +143,7 @@\n \t}\n \n \tif processedCount == 0 {\n-\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n+\t\treturn 1, fmt.Errorf(\"no configurations were successfully processed\")\n \t}\n \n \treturn processedCount, nil\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.45\" with checksum b7c00dd2fab93569748376fe9aca7ae4\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 11*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -152,7 +152,7 @@\n func main() {\n \t// This main function tests all our functions\n \tconfigs := []TestConfig{\n-\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n+\t\tcreateTestConfig(\"test1\", 11*time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.46\" with checksum 12ed84a97f3a2301352930137601954f\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 21*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -153,7 +153,7 @@\n \t// This main function tests all our functions\n \tconfigs := []TestConfig{\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n-\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n+\t\tcreateTestConfig(\"test2\", 21*time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n \t}\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.47\" with checksum bb2e708a4d3af6bd817a343f8d059d94\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 31*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -154,7 +154,7 @@\n \tconfigs := []TestConfig{\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n-\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n+\t\tcreateTestConfig(\"\", 31*time.Second, true), // Invalid\n \t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n \t}\n \n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.48\" with checksum 2c1f6de08ec0c09c344e0b18bb5bbff8\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 41*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -155,7 +155,7 @@\n \t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n \t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n \t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n-\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n+\t\tcreateTestConfig(\"test3\", 41*time.Second, true),\n \t}\n \n \tvalidConfigs := filterValidConfigs(configs)\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.49\" with checksum 5c0408527f18e6a0dfce36cbe59bac3d\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 3)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -162,14 +162,14 @@\n \tresults := processConfigs(validConfigs)\n \tsuccessCount := countSuccessful(results)\n \n-\tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\tprocessed, err := validateAndProcessBatch(configs, 3)\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.50\" with checksum 0ffc3e0bc01cec186cb30310223d729d\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\t_ = validCount\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -133,8 +133,8 @@\n \n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n-\t\t\tvalidCount++\n-\t\t\t\n+\t\t\t_ = validCount\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,13 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n+\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\",\n \t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n+\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.51\" with checksum eb52a8c2a25d52f337bd28f774cfaacb\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\t\t\t\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\t\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\n\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n\t\tlen(validConfigs), successCount, processed, pipelineResult)\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo\"\n\t\"github.com/samber/mo\"\n)\n\n// Test data structures for mutation testing\ntype TestConfig struct {\n\tname    string\n\ttimeout time.Duration\n\tenabled bool\n}\n\ntype TestResult struct {\n\tdata  mo.Option[interface{}]\n\terror mo.Option[error]\n}\n\nfunc (r *TestResult) IsSuccess() bool {\n\treturn r.data.IsPresent() \u0026\u0026 r.error.IsAbsent()\n}\n\nfunc (r *TestResult) GetData() mo.Option[interface{}] {\n\treturn r.data\n}\n\nfunc (r *TestResult) GetError() mo.Option[error] {\n\treturn r.error\n}\n\n// Pure functions for testing - these will be mutated\nfunc createTestConfig(name string, timeout time.Duration, enabled bool) TestConfig {\n\treturn TestConfig{\n\t\tname:    name,\n\t\ttimeout: timeout,\n\t\tenabled: enabled,\n\t}\n}\n\nfunc validateConfig(config TestConfig) bool {\n\treturn config.name != \"\" \u0026\u0026 config.timeout \u003e 0\n}\n\nfunc filterValidConfigs(configs []TestConfig) []TestConfig {\n\treturn lo.Filter(configs, func(config TestConfig, _ int) bool {\n\t\treturn validateConfig(config)\n\t})\n}\n\nfunc processConfig(config TestConfig) *TestResult {\n\tif !validateConfig(config) {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.None[interface{}](),\n\t\t\terror: mo.Some[error](fmt.Errorf(\"invalid config\")),\n\t\t}\n\t}\n\n\tprocessedData := map[string]interface{}{\n\t\t\"name\":         config.name,\n\t\t\"timeout_sec\":  config.timeout.Seconds(),\n\t\t\"enabled\":      config.enabled,\n\t\t\"processed_at\": time.Now().Unix(),\n\t}\n\n\treturn \u0026TestResult{\n\t\tdata:  mo.Some[interface{}](processedData),\n\t\terror: mo.None[error](),\n\t}\n}\n\nfunc processConfigs(configs []TestConfig) []*TestResult {\n\treturn lo.Map(configs, func(config TestConfig, _ int) *TestResult {\n\t\treturn processConfig(config)\n\t})\n}\n\nfunc countSuccessful(results []*TestResult) int {\n\treturn lo.CountBy(results, func(result *TestResult) bool {\n\t\treturn result.IsSuccess()\n\t})\n}\n\nfunc createResult(success bool, data interface{}, err error) *TestResult {\n\tif success {\n\t\treturn \u0026TestResult{\n\t\t\tdata:  mo.Some[interface{}](data),\n\t\t\terror: mo.None[error](),\n\t\t}\n\t}\n\treturn \u0026TestResult{\n\t\tdata:  mo.None[interface{}](),\n\t\terror: mo.Some[error](err),\n\t}\n}\n\n// Critical function for mutation testing - this has conditional logic that should be tested\nfunc processNamesPipeline(names []string) int {\n\t// This function has multiple steps that can be mutated\n\tif len(names) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 1: Filter out empty strings\n\tfiltered := lo.Filter(names, func(name string, _ int) bool {\n\t\treturn name != \"\"\n\t})\n\n\tif len(filtered) == 0 {\n\t\treturn 0\n\t}\n\n\t// Step 2: Add prefix to each name\n\tprefixed := lo.Map(filtered, func(name string, _ int) string {\n\t\treturn \"processed_\" + name\n\t})\n\n\t// Step 3: Count results\n\treturn len(prefixed)\n}\n\n// Complex function with multiple conditional branches for mutation testing\nfunc validateAndProcessBatch(configs []TestConfig, minSize int) (int, error) {\n\tif len(configs) \u003c minSize {\n\t\treturn 0, fmt.Errorf(\"batch too small: need at least %d configs\", minSize)\n\t}\n\n\tvalidCount := 0\n\tprocessedCount := 0\n\n\tfor _, config := range configs {\n\t\tif validateConfig(config) {\n\t\t\tvalidCount++\n\n\t\t\tresult := processConfig(config)\n\t\t\tif result.IsSuccess() {\n\t\t\t\tprocessedCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif processedCount == 0 {\n\t\treturn 0, fmt.Errorf(\"no configurations were successfully processed\")\n\t}\n\n\treturn processedCount, nil\n}\n\nfunc main() {\n\t// This main function tests all our functions\n\tconfigs := []TestConfig{\n\t\tcreateTestConfig(\"test1\", 10*time.Second, true),\n\t\tcreateTestConfig(\"test2\", 20*time.Second, false),\n\t\tcreateTestConfig(\"\", 30*time.Second, true), // Invalid\n\t\tcreateTestConfig(\"test3\", 40*time.Second, true),\n\t}\n\n\tvalidConfigs := filterValidConfigs(configs)\n\tresults := processConfigs(validConfigs)\n\tsuccessCount := countSuccessful(results)\n\n\tprocessed, err := validateAndProcessBatch(configs, 2)\n\n\tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n\t_, _, _, _, _ = fmt.Printf, validConfigs, successCount, processed, pipelineResult\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n","originalFilePath":"functional_test_source.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -134,7 +134,7 @@\n \tfor _, config := range configs {\n \t\tif validateConfig(config) {\n \t\t\tvalidCount++\n-\t\t\t\n+\n \t\t\tresult := processConfig(config)\n \t\t\tif result.IsSuccess() {\n \t\t\t\tprocessedCount++\n@@ -163,13 +163,11 @@\n \tsuccessCount := countSuccessful(results)\n \n \tprocessed, err := validateAndProcessBatch(configs, 2)\n-\t\n+\n \tpipelineResult := processNamesPipeline([]string{\"alice\", \"bob\", \"\", \"charlie\"})\n+\t_, _, _, _, _ = fmt.Printf, validConfigs, successCount, processed, pipelineResult\n \n-\tfmt.Printf(\"Valid configs: %d, Success count: %d, Processed: %d, Pipeline: %d\\n\", \n-\t\tlen(validConfigs), successCount, processed, pipelineResult)\n-\t\n \tif err != nil {\n \t\tfmt.Printf(\"Error: %v\\n\", err)\n \t}\n-}\n\\ No newline at end of file\n+}\n","processOutput":"PASS \"/tmp/go-mutesting-3648143002/functional_test_source.go.53\" with checksum d6191107bdef8d2ff04d99b8331bfd02\n"}],"errored":null}